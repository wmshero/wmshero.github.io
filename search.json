[{"title":"React Hooks 的实现原理是什么?为什么 Hooks不能在条件语句或循环中使用?","path":"/2025/12/09/react-hook/","content":"React Hooks(如 useState，useEffect )的出现，彻底改变了 React 函数组件的编写方式。其看似神奇的实现原理，背后是闭包和链表(或数组)数据结构的精巧运用。在 React 内部，每个函数组件实例都对应一个 Fiber 节点。这个 Fiber 节点内部维护着一个有序的数据结构(可以想象成一个链表或数组)，专门用来存储该组件所有 Hooks 的状态。当组件首次渲染时，每调用一个 Hook(如useState(initial))，React 就会创建一个对应的 Hook 对象，并将其按调用顺序存入这个内部链表中当组件因为状态变化而再次渲染时，函数组件的代码会重新执行。每当遇到一个 Hook 调用，React 就会从内部链表中，按照上一次渲染时完全相同的顺序，取出对应的 Hook 对象，从而读取到之前保存的状态。 setstate 函数之所以能更新状态，是因为它通过闭包捕获了指向特定 Hook 对象的引用，并触发一个更新调度。 正是这种强依赖于调用顺序的机制，决定了 Hooks 的核心使用规则:只能在组件的顶层调用，绝不能在条件语句循环或嵌套函数中使用。如果在不同渲染之间，Hooks 的调用顺序或数量发生变化，React 内部的指针就会错位，无法将当前的 Hook 调用与正确的历史状态关联起来，导致状态混乱和不可预测的 bug。 React 通过调用顺序识别 Hooks，打乱顺序会导致状态映射错误。 这一规则看似限制，实则是其实现原理的直接体现， 推荐阅读文章：我打破了 React Hook 必须按顺序、不能在条件语句中调用的枷锁","tags":["React"],"categories":["现代框架应用和原理剖析"]},{"title":"响应式原理对比:Vue 的 Proxy 和 React 的 setState 有什么本质区别?","path":"/2025/12/09/proxyAndSetState/","content":"Vue 和 React 在处理状态到视图的更新上，走了两条截然不同的技术路线，这体现了它们在设计哲学上的根本差异。 Vue 采用的是一种基于依赖追踪的、细粒度的自动响应式系统。在 Vue3中，通过 Proxy(Vue 2 中为0bject.defineProperty)对数据对象进行代理。当组件渲染时，它会访问这些数据，触发代理的 get 拦截器。此时，Vue 会将当前正在渲染的组件的更新函数 (effect )作为“依赖”，收集起来。当数据被修改时，会触发 set 拦截器，Vue 会精确地找到所有依赖该数据的 effect，并重新执行它们。这个过程是自动且精准的，开发者只需关心数据的修改，视图更新由框架透明地完成。 相比之下，React 的更新机制是基于不可变性(Immutability)和手动触发的。React 本身并不“知道”你的数据何时以及如何变化。你必须通过调用 setstate(或 useState 的更新函数)来明确告知 React:“状态已变，请启动更新”。收到通知后，React 会将该组件及其子组件标记为“脏”，然后启动自上而下的协调过程，通过 Diff 算法找出变化并更新 DOM。这种方式默认是“粗粒度”的，但通过 React.memo 等优化手段可以避免不必要的子组件渲染。 总结来说，Vue 像是为每个数据配备了一个“监视器”，一旦数据变动，立即通知所有相关方;而 React 则像是一个项目经理”，你必须向它提交一份“变更报告”(setState)，它才会组织团队(组件树)进行一次全面的“评审’(re-render 和diff)。","tags":["React","Vue"],"categories":["现代框架应用和原理剖析"]},{"title":"React 的 Fiber架构是什么?它解决了什么问题?","path":"/2025/12/08/react-fiber/","content":"在 React 16 之前，协调(Reconciliation)过程是同步且递归的，一旦开始就无法中断。对于复杂的组件树，这个过程可能耗时很长，导致主线程被长时间占用，页面因此失去响应，出现卡顿和掉帧。为了解决这一顽疾，React引入了 Fiber 架构。 Fiber 不仅仅是一个新特性，而是对 React 核心协调算法的彻底重构。其核心思想是将一个庞大的、不可中断的更新任务，拆分成许多微小的工作单元(Fiber 节点)。每个 Fiber 节点代表了一个组件实例、DOM 节点或其他工作。React 可以在每完成一个工作单元后，暂停下来，将控制权交还给主线程，检查是否有更高优先级的任务(如用户输入)需要处理。 这种异步可中断的更新机制，带来了两大革命性变化: 告别主线程阻塞:通过将更新过程碎片化，React 能够在浏览器的每一帧(约16.6ms)的空闲时间内执行一部分工作。如果时间用尽，它会优雅地暂停，等待下一帧的空闲时间再继续、从而确保了动画、布局和用户输入的流畅性。 实现任务优先级调度:Fiber 架构为不同类型的更新赋予了优先级。例如，由用户输入触发的更新优先级最高，而数据获取触发的更新优先级较低。高优先级的任务可以“插队”，中断正在进行的低优先级任务，确保应用始终能快速响应用户。 本质上，Fiber 将 React 的更新从一个“霸道”的同步任务，转变为一个“懂礼貌”的、可与浏览器协作的调度系统，这是现代复杂 React 应用能够保持高性能和优秀用户体验的基石。","tags":["React"],"categories":["现代框架应用和原理剖析"]},{"title":"Vite 为什么比 Webpack 在开发环境下快得多?它的原理是什么?","path":"/2025/12/08/viteAndWebpack/","content":"Vite 在开发环境下之所以能实现远超 Webpack 的“秒级”启动和热更新速度，其秘诀在于它颠覆了传统 bundler 的工作模式，充分利用了现代浏览器原生支持的 ES Modules (ESM)。 传统的 Webpack Dev Server，在启动时必须先遍历所有模块，构建完整的依赖图，然后将整个应用打包到内存中,项目越庞大，这个初始的打包过程就越耗时。 Vite 则完全不同。它启动时，几乎不做任何打包工作。它直接以项目源码作为服务根目录，当浏览器发起请求时，例如请求 main.is，Vite Dev Server 会直接返回这个文件。浏览器会解析文件中的 import 语句，然后按需发起对其他模块(如 import App from ./App.vue)的HTTP 请求。Vite 会拦截这些请求，即时(Just-in-Time)地对被请求的模块进行编译转换(如将 .vue 文件编译成 JavaScript)，然后以原生 ESM 的格式返回给浏览器。 这种按需编译的模式，意味着只有当代码实际被请求时，Vite 才会去处理它。应用的启动时间不再与项目的大小成正比。而在热更新(HMR)时，Vite 只需让被修改的模块失效，并精确地通知浏览器重新请求这一个模块即可，无需重新构建整个 bundle。这种极致的效率，为前端开发带来了前所未有的流畅体验。当然，在生产环境中，Vite 还是会使用 Rollup 进行打包，以获得最佳的性能和兼容性。","categories":["前端工程化"]},{"title":"从概念到实践讲讲js函数式编程","path":"/2025/12/07/js-function-programming/","content":"函数式编程（Functional Programming，FP）是一种以函数为核心的编程范式，强调通过纯函数、不可变数据、函数组合等方式构建程序，而非依赖状态修改和指令式流程。与传统的命令式编程（一步步告诉计算机 “怎么做”）不同，函数式编程更关注 “做什么”，追求代码的简洁、可复用、可测试性。 一、先搞懂：什么是 JS 函数式编程？先通过命令式 vs 函数式的对比示例，直观感受核心差异： 场景：筛选数组中大于 10 的偶数并翻倍 命令式编程（传统写法） // 命令式：关注“步骤”，手动管理状态和循环const arr = [1, 12, 5, 20, 7, 18];const result = [];for (let i = 0; i arr.length; i++) const item = arr[i]; // 步骤1：筛选大于10的数 if (item 10) // 步骤2：筛选偶数 if (item % 2 === 0) // 步骤3：翻倍并存入结果 result.push(item * 2); console.log(result); // [24, 40, 36] 函数式编程（FP 写法） // 函数式：关注“结果”，用纯函数组合实现逻辑const arr = [1, 12, 5, 20, 7, 18];// 1. 定义纯函数（无副作用、输入决定输出）const isGreaterThan10 = (num) = num 10;const isEven = (num) = num % 2 === 0;const double = (num) = num * 2;// 2. 用数组高阶函数（map/filter）组合逻辑const result = arr .filter(isGreaterThan10) .filter(isEven) .map(double);console.log(result); // [24, 40, 36] 函数式编程的核心特征（从示例中提炼） 纯函数（Pure Function）： 输入相同，输出必然相同（无随机值、无依赖外部状态）； 无副作用（不修改外部变量、不操作 DOM、不发请求）； 示例中 isGreaterThan10isEvendouble 都是纯函数。 不可变数据（Immutable Data）： 不修改原始数据，而是返回新数据（示例中 filtermap 均返回新数组，原数组 arr 未被修改）； JS 中可通过 Object.freeze、展开运算符 ...、Object.assign 实现简单不可变。 高阶函数（Higher-Order Function）： 接受函数作为参数，或返回函数的函数（示例中 filtermap 是高阶函数，接收纯函数作为参数）； JS 内置高阶函数：mapfilterreduceforEachsort 等。 函数组合（Function Composition）：将多个小函数组合成一个大函数，实现复杂逻辑（示例中 filter+filter+map 就是简单的组合）。 二、深入实践：函数式编程的核心用法 纯函数：避免副作用 反例（不纯函数）：依赖外部变量、修改外部状态 let globalNum = 10;// 不纯：依赖外部变量，输入相同但输出可能不同const add = (num) = num + globalNum;// 不纯：修改外部数组（副作用）const pushItem = (arr, item) = arr.push(item); return arr;; 正例（纯函数）： // 纯函数：输入决定输出，无外部依赖const add = (num1, num2) = num1 + num2;// 纯函数：返回新数组，不修改原数组const pushItem = (arr, item) = [...arr, item];// 测试：输入相同，输出必相同console.log(add(2, 3)); // 5（永远）console.log(pushItem([1,2], 3)); // [1,2,3]（原数组仍为[1,2]） 不可变数据：避免状态混乱 const user = name: 张三, age: 20 ;// 命令式：修改原对象（副作用）user.age = 21;console.log(user); // name: 张三, age: 21 // 函数式：返回新对象，原对象不变const updatedUser = ...user, age: 21 ;console.log(user); // name: 张三, age: 20 （原对象未变）console.log(updatedUser); // name: 张三, age: 21 函数组合：封装复杂逻辑手动实现 “函数组合” 工具，将多个单职责函数组合成一个函数： // 组合函数：从右到左执行（先执行最后一个函数，结果传给前一个）const compose = (...fns) = (x) = fns.reduceRight((acc, fn) = fn(acc), x);// 复用之前的纯函数const isGreaterThan10 = (num) = num 10;const isEven = (num) = num % 2 === 0;const double = (num) = num * 2;// 组合成新函数：先筛选10 → 筛选偶数 → 翻倍const processNum = compose(double, isEven, isGreaterThan10); // 注意顺序（从右到左）// 扩展：数组处理的组合函数const processArr = (arr) = arr.filter(compose(isEven, isGreaterThan10)).map(double);console.log(processArr([1, 12, 5, 20, 7, 18])); // [24, 40, 36] 柯里化（Currying）：函数参数复用柯里化是将多参数函数转换为单参数函数的过程，核心是 “参数复用”： // 柯里化工具函数const curry = (fn) = return function curried(...args) // 若参数足够，执行原函数；否则返回新函数接收剩余参数 if (args.length = fn.length) return fn.apply(this, args); else return function (...args2) return curried.apply(this, args.concat(args2)); ; ;;// 原多参数函数const add = (a, b, c) = a + b + c;// 柯里化后const curriedAdd = curry(add);// 用法1：分步传参（复用参数）const add5 = curriedAdd(5); // 固定第一个参数为5const add5And6 = add5(6); // 固定第二个参数为6console.log(add5And6(7)); // 5+6+7=18// 用法2：直接传所有参数console.log(curriedAdd(1,2,3)); // 6 三、为什么要用函数式编程？ 代码更简洁、易读摒弃冗长的循环、条件判断嵌套，用 “函数组合” 替代 “步骤式指令”；单职责函数语义清晰（如 isEvendouble 一看就懂，无需注释）。 易测试、易调试纯函数无依赖、无副作用，测试时只需关注 “输入→输出”，无需模拟外部状态；调试时可直接单独运行某个纯函数，定位问题更高效。 // 测试纯函数（无需任何环境准备）test(isEven should return true for even numbers, () = expect(isEven(2)).toBe(true); expect(isEven(3)).toBe(false);); 避免状态混乱不可变数据杜绝了 “意外修改共享状态” 的问题（多线程 异步场景下尤为重要）；例如 React 中，state 必须通过setState 修改（不可变思想），避免组件状态异常。 代码复用性更高纯函数、柯里化、函数组合可快速封装通用逻辑（如表单验证、数据处理）；例如：封装一个通用的 “数据筛选 + 转换” 函数，可复用在多个业务场景。 四、函数式编程的优点与局限 优点 具体说明 可读性高 语义化函数名替代指令式步骤，代码接近自然语言 可维护性强 单职责函数低耦合，修改一个函数不影响其他逻辑 可测试性好 纯函数无依赖，单元测试无需复杂的环境模拟 并行安全 不可变数据避免多线程 异步场景下的 “竞态条件”（JS 中主要体现在异步代码） 复用性高 柯里化、组合函数可快速封装通用逻辑 局限 具体说明 性能开销 不可变数据会创建大量新对象（如频繁修改大数组 对象时，内存占用高于命令式） 学习成本高 柯里化、组合、函子等概念较抽象，新手难理解 不适合所有场景 简单的 “一次性逻辑”（如临时遍历数组）用函数式可能比命令式更繁琐 调试难度增加 多层函数组合时，定位问题需要跟踪函数执行链（可通过中间件 日志改善） 五、使用建议 不要 “一刀切”：混合范式JS 是多范式语言，无需完全抛弃命令式，按需使用函数式；例如：简单的循环用 for 没问题，复杂的数据处理用 filtermapreduce，状态管理用不可变思想。 优先使用内置高阶函数优先用 map/filter/reduce/find 等内置函数，避免手动写循环；例如：reduce 可替代大部分 “遍历 + 累加 聚合” 逻辑，代码更简洁。 合理使用工具库（避免重复造轮子）简单场景：手写柯里化、组合函数；复杂场景：使用成熟的函数式库（如 lodash/fp、ramda），内置了大量纯函数、柯里化、组合工具。 // lodash/fp 示例（自动柯里化、不可变）import fp from lodash/fp;const processArr = fp.flow( fp.filter(fp.gt(fp.__, 10)), // __ 是占位符 fp.filter(fp.even), fp.map(fp.multiply(2)));console.log(processArr([1, 12, 5, 20, 7, 18])); // [24, 40, 36] 避免过度抽象不要为了 “函数式” 而强行柯里化 组合，简单逻辑保持简洁；例如：const add = (a,b) = a+b 比柯里化后的 curriedAdd(1)(2) 更易读。 结合框架使用React：函数组件 + Hooks（纯函数思想）、Redux（不可变状态）都是函数式的典型应用；Vue：Pinia/Vuex 中的状态修改需通过 action/mutation（不可变思想）。 六、总结函数式编程的核心是用纯函数构建无副作用的逻辑，它不是 “银弹”，但能显著提升代码的可维护性、可测试性。在 JS 中，我们无需精通所有函数式概念（如函子、单子），只需掌握 “纯函数、不可变、高阶函数、函数组合” 这几个核心，就能在实际开发中受益。 最终建议：以 “解决问题” 为核心，将函数式思想融入日常开发，而非机械套用范式 —— 简单逻辑保持直观，复杂逻辑用函数式简化，这才是 JS 函数式编程的最佳实践。","tags":["React"]},{"title":"关键渲染路径(Critical Rendering Path)是什么？以及如何对其进行优化?","path":"/2025/06/09/crp/","content":"关键渲染路径(Critical Rendering Path,CRP)是浏览器将 HTML、CSS 和JavaScript 转换为屏幕上像素所经历的一系列步骤。优化 CRP，就是缩短这个过程的时间，让用户尽快看到有意义的内容，这是提升首屏性能的核心。这个路径始于浏览器接收到 HTML 文档。首先，浏览器会解析 HTML，构建起DOM 树。在解析过程中，如果遇到 CSS 文件的链接，会异步下载并解析，构建CSSOM 树。这两个过程通常是并行的。然而，当解析器遇到script标签时，情况就变得复杂了–默认情况下，HTML 解析会暂停，等待脚本下载并执行完毕，因为 JavaScript 可能会修改 DOM。这就是所谓的“渲染阻塞”当 DOM 和 CSSOM 都构建完毕后，浏览器会将两者合并成渲染树(RenderTree)，它只包含页面上可见的节点及其样式。紧接着，浏览器会根据渲染树进行布局(Layout)，计算出每个节点在屏幕上的精确位置和尺寸。最后一步是绘制(Paint)，浏览器将节点绘制成屏幕上的像素。 优化 CRP 的策略就是围绕“减少阻塞”和“缩短路径”展开: 对于 JavaScript:将 script 标签放置在 /body前，或使用defer/async 属性。 defer 能保证脚本在 HTML 解析完毕后按顺序执行，而 async 则是在下载完毕后立即执行，两者都能避免阻塞 DOM 构建 对于 CSS:CSS 默认是渲染阻塞资源。我们可以将首屏渲染必需的关键 CSS 内联到 HTML 的 head中，而将非关键 CSS 通过异步方式加载，从而让渲染树能尽快构建和绘制。 减少资源:压缩文件、启用 Gzip、利用 HTTP/2 等手段，都能加快关键资源的下载速度，从而缩短整个 CRP 的耗时。","tags":["性能优化"],"categories":["性能优化"]},{"title":"CSS-in-JS 和原子化 CSS 的核心思想是什么?如何进行技术选型?","path":"/2025/04/10/modern-css/","content":"CSS工程化方案中，CSS-in-JS (如 Styled-components)和原子化 CSS (如 Tailwind css)的核心思想是什么? 如何进行技术选型?在现代前端开发中，如何组织和管理 CSS已经演变成一个重要的架构决策。其中，CSS-in-JS(如 Styled-components)和原子化 CSS(如 Tailwind css)代表了两种主流但哲学迥异的方案。 CSS-in-JS 的核心思想是组件级别的样式封装。它将 CSS 模型的粒度从整个应用缩小到了单个组件。通过将样式直接写在 JavaScript 或 TypeScript 文件中，我们实现了样式与组件逻辑的高内聚。这种方式天然地解决了 CSS 全局命名冲突问题，因为样式作用域被限定在组件内部。同时，借助 JavaScript 的能力，可以轻松实现基于 props 的动态样式、主题切换等高级功能。它的代价是可能引入一些运行时开销，并且需要开发者适应一种新的样式编写范式。 原子化 CSS则奉行“功能优先”的哲学。它提供了一个庞大但设计精良的、由单一用途的工具类(utility classes)组成的集合，如 flex，pt-4(padding-top:1rem)，text-center。开发者不再为每个组件编写独立的 CSS，而是通过在 HTML 中组合这些原子类来快速构建界面。这种方式极大地提升了开发效率，避免了为命名而烦恼，并能强制推行统一的设计系统。通过 JT(Just-in-Time)编译器，最终打包的 CSS 文件体积极小，只包含实际用到的类。它的缺点是可能导致 HTML 结构中的 class 列表变得冗长，对于不熟悉其命名体系的开发者有一定学习曲线。 总结： 技术选型上，如果项目组件化程度极高，需要复杂的动态和主题化样式，那么 CSS-in-JS 是一个优秀的选择。而如果追求极致的开发效率、严格的设计规范和最佳的打包性能，尤其是在构建原型和标准化界面时，原子化 CSS 则更具优势。","tags":["CSS"]},{"title":"什么是微前端架构?它的核心价值和主要挑战是什么?","path":"/2025/03/10/micro-frontend/","content":"微前端是一种类似于微服务的架构思想在前端领域的应用。它旨在将一个庞大、笨重的单体(Monolithic)Web应用，拆解成多个更小、更专注、可以独立开发、测试、部署和演进的“微应用”。 这些微应用最终在主应用(或称基座)的协调下，被无缝地集成在一起，共同构成一个完整的用户体验，其核心价值在于解决了大型应用在工程、组织和技术层面的痛点: 技术栈无关:允许不同团队为各自的微应用选择最合适的技术栈(React,vue,Angular 等)，这对于渐进式重构老旧系统或尝试新技术尤为重要。 团队自治与独立部署:每个微应用可以由一个独立的团队全权负责，拥有自己的代码库和部署流水线，极大地降低了团队间的协作耦合，使得发布更加频繁和安全。 增量升级与容错:可以独立地升级或重写应用的某个部分，而无需对整个系统进行伤筋动骨的改造。单个微应用的故障影响范围也更可控。 当然，微前端也带来了新的挑战，如应用间通信、样式隔离、路由管理、公共依赖的共享和版本控制等。为此，社区也涌现出了如 single-spa、 qiankun 和 Webpack Module Federation 等成熟的解决方案，它们通过路由劫持、JS 沙箱、CSS 作用域等技术，帮助我们应对这些挑战。","categories":["前端工程化"]},{"title":"虚拟DOM、diff算法、fiber","path":"/2024/11/10/virtual-dom-fiber/","content":"虚拟 DOM (VirtualDOM)的本质是什么?Diff 算法是如何工作的?为什么需要 key ?直接操作真实 DOM 的开销是昂贵的，因为它会触发浏览器复杂的渲染流水线，包括重排(Reflow)和重绘(Repaint)。为了最大限度地减少对真实 DOM 的操作，React 引入了虚拟 DOM (Virtua DOM)的概念。 虎拟 DOM 的本质是一个轻量级的 JavaScript 对象，它是对真实 DOM 结构的一层抽象和描述。当组件状态发生变化时，React 并不直接修改真实 DOM，而是遵循一个“三步走”策略: 1.在内存中根据新的状态，生成一棵新的虚拟 DOM 树。 2.通过 Diff 算法，比较新旧两棵虚拟 DOM 树的差异。 3.将计算出的最小化差异(patches)，以批处理的方式，一次性地应用到真实 DOM 上。 React 的 Diff 算法为了实现高效对比，做出了几个关键的权衡和假设。它只进行同层级比较，并且只有当节点类型相同时才会继续深入比较。而对于同层级的一组子节点(例如列表)，key 属性扮演了至关重要的角色。 key 是节点的唯一标识符。如果没有 key，当列表发生变化(如在开头插入一个元素)时，React 只能按位置逐一对比，这会错误地导致后续所有节点都被认为是“更新”了，从而进行大量不必要的 DOM 操作。而有了稳定且唯-的 key，React 就能精确地识别出哪些节点是新增的、哪些是删除的、哪些只是移动了位置。这使得 React 可以最大限度地复用已有的 DOM 元素，极大地提升了列表更新的性能。因此，key 的正确使用是 React 性能优化的一个核心实践。 Virtual DOM 的引入带来了以下好处 提高性能：Virtual DOM 通过将真实 DOM 的操作转换为对虚拟 DOM 的操作，然后批量更新到真实 DOM 中，减少了对真实 DOM 的频繁操作。这样可以提高页面渲染的性能，减少了浏览器重绘和重排的次数，提升了用户体验。 减少 DOM 操作的次数：虚拟 DOM 可以将多次操作合并为一次操作，比如添加 1000 个节点，却是一个接一个操作的； 减少 DOM 操作的范围：虚拟 DOM 借助 DOM diff 可以把多余的操作省掉，比如添加 1000 个节点，其实只有 10 个是新增的。 简化开发：使用 Virtual DOM 可以使开发人员更专注于应用程序的逻辑和数据，而不必过多地关注 DOM 操作的细节。通过使用组件化开发模式，开发人员可以将 UI 拆分成小而独立的组件，每个组件都有自己的状态和行为，这样可以更容易地管理和维护应用程序的代码。 跨平台兼容性：由于 Virtual DOM 是一个与平台无关的抽象层，因此可以轻松地将 React 应用程序移植到不同的平台上，包括 Web、移动端和桌面端等。这样可以提高应用程序的可移植性和跨平台兼容性。 方便的测试：使用 Virtual DOM 可以方便地进行单元测试和集成测试，因为可以在内存中操作虚拟 DOM，而无需真实的浏览器环境。这样可以加快测试速度，提高开发效率。 虚拟 DOM 长什么样子？react:const vNode= key:null, props: children:[ type:span,..., type:span,..., ], className:red, onClick:()= , ref:null, type:div, ... vue:const vNode= tag:div, data: class:red, on: click:()= , children:[ tag:span,..., tag:span,..., ], ... 实现虚拟 DOM 例子 定义虚拟 DOM 元素 创建文本节点 将虚拟 DOM 渲染为真实 DOM // 定义虚拟 DOM 元素const createElement = (type, props, ...children) = return type, props: ...props, children: children.map((child) = typeof child === object ? child : createTextElement(child) ), , ;;// 创建文本节点const createTextElement = (text) = return type: TEXT_ELEMENT, props: nodeValue: text, children: [], , ;;// 将虚拟 DOM 渲染为真实 DOMconst render = (element, container) = const dom = element.type === TEXT_ELEMENT ? document.createTextNode() : document.createElement(element.type); const isProperty = (key) = key !== children; Object.keys(element.props) .filter(isProperty) .forEach((name) = dom[name] = element.props[name]; ); element.props.children.forEach((child) = render(child, dom)); container.appendChild(dom);;// React 的 createElement 和 render 函数使用const MyReact = createElement, render,;// 使用示例const element = MyReact.createElement( div, id: container , MyReact.createElement(h1, null, Hello, World!), MyReact.createElement(p, null, This is a paragraph.));const container = document.getElementById(root);MyReact.render(element, container); 虚拟 DOM 的缺点需要额外的创造函数，如 createElement 或 h,但可以通过 JSX 来简化 XML 写法，严重依赖打包工具 diff 算法 虚拟 DOM 树比较：在进行更新时，React 会将当前的虚拟 DOM 树与新的虚拟 DOM 树进行比较，找出差异。 差异检测：React 使用 深度优先搜索算法（DFS）对比两棵虚拟 DOM 树，找出两棵树之间的差异。它会逐个比较节点及其子节点，找出哪些节点需要更新、添加或删除。 Diff 策略：React 使用了一些优化策略来减少 DOM 操作次数： 同层比较：React 只会对比相同层级的节点，不会跨层级比较。 唯一标识：在进行节点比较时，React 会使用节点的唯一标识（通常是 key 属性）来判断节点是否相同，从而避免不必要的更新操作。 节点移动：React 会尽量复用已存在的节点，而不是重新创建新的节点。如果节点顺序改变，React 会尝试通过移动节点来达到更新效果，而不是直接删除和重新插入节点。 批量更新：React 会将多个更新操作合并成一个批量更新，然后一次性更新到真实 DOM 中，以减少页面重绘和重排的次数。 应用差异：一旦找到了两棵虚拟 DOM 树之间的差异，React 就会根据这些差异来进行相应的操作，更新真实 DOM。 vue 中的 diff 算法在对新旧虚拟 dom 对比时，是从节点的两侧向中间对比，如果节点的 key 值和元素类型相同，属性值不同，就认为是不同节点，会将该节点删除重建react 中的 diff 算法在对新旧虚拟 dom 对比时，是从节点的左边向右边对比，如果节点的 key 值和元素类型相同，属性值不同，就认为是节点同类型，只修改当前节点的属性 逻辑 Tree diff 将新旧两棵树逐层对比，找出哪些节点需要更新 如果节点是组件就看 Component diff 如果节点是标签就看 Element diff Component diff 如果节点是组件，就先看组件类型 类型不同直接替换（删除旧的） 类型相同则只更新属性 然后深入组件做 Tree diff(递归) Element diff 如果节点是原生标签，则看标签名 标签名不同直接替换，相同则只更新属性 然后进入标签后代做 Tree diff(递归) dom diff 有什么缺点同级比较，存在 BUG，需要加个 唯一 Key,不能用 index 做下标 FiberFiber 是 React v16 中引入的一种新的协调算法，用于调度和管理 React 的渲染和更新过程。Fiber 的目标是使 React 应用程序更加流畅和响应，减少页面卡顿和掉帧的情况。Fiber 的核心思想是将 React 的渲染过程分解为可中断的小任务，并且可以根据优先级来调度这些任务的执行顺序。这样可以使 React 在执行渲染任务时更加灵活，可以根据页面的需要来调整任务的优先级和执行顺序，从而提高用户体验。 Fiber 的引入使得 React 具备了更高的并发能力和更灵活的调度策略，使得 React 应用程序可以更好地适应不同的场景和用户需求。 综上所述，Virtual DOM 和 Fiber 是 React 内部机制中的两个关键概念，它们共同作用于 React 的渲染和更新过程中，提高了 React 应用程序的性能、效率和响应能力。Virtual DOM 优化了对真实 DOM 的操作，而 Fiber 则优化了 React 的渲染和更新调度过程。 关于 DOM 的谣言:DOM 操作慢？虚拟 DOM 快这句话类似于：刘翔矮（对比于姚明）DOM 操作慢是对比于 JS 原生 API，如数组操作任何基于 DOM 的库（VueReact）都不可能再操作 DOM 时比 DOM 快 为什么网上有这样的谣言？因为在某些情况下，虚拟 DOM 快 规模太大的时候，比如 100000 个节点，原生 DOM 要快，因为虚拟 DOM 要做大量的计算，规模小的时候（1000 个节点），虚拟 DOM 快 在测试插入 10000 个节点的时候，vue 要比 react 快很多，vue 的速度接近原生 JS，当然这两个都没有做任何优化","tags":["React"],"categories":["现代框架应用和原理剖析"]},{"title":"从浏览器地址栏输入url到请求返回发生了什么?其中哪些环节可以进行性能优化？","path":"/2024/08/25/input-url-brower/","content":"总结：当用户在浏览器地址栏输入 URL 并按下回车，一场跨越网络和计算机内部的复杂协作便拉开了序幕。这个过程是前端知识体系的全面体现。 旅程始于 DNS 查询，浏览器需要将用户输入的域名(如 google.com)解析为服务器的IP 地址。这个过程会依次查询浏览器缓存、系统缓存、路由器缓存，直至向 DNS 服务器发起请求。拿到 IP 地址后，浏览器会通过三次握手与服务器建立一条可靠的TCP 连接。如果网站是 HTTPS 的，还需要在此之上进行一次 TLS 握手，以建立加密信道。连接建立后，浏览器便可以发送 HTTP 请求报文，服务器接收到请求后，进行外理，可能涉及数据库查询，业务逻辑计算等，然后返回一个 HTTP 响应报文，其中包含了状态码(如 200 0K )和响应体(通常是 HTML 内容)。浏览器接收到 HTML 后，渲染引擎开始工作，进入关键渲染路径。它会解析 HTML 构建 DOM，解析 CSS 构建CSSOM。在解析过程中，如果遇到其他资源引用(如 JS、图片、字体文件)，浏览器会为这些资源再次发起 HTTP 请求。这些后续请求可能会复用已建立的 TCP 连接(得益于 HTTP 持久连接或 HTTP2 的多路复用)，从而提高效率。最终，页面被渲染出来，并在后续的“水合”过程中绑定交互事件。几乎每个环节都存在优化空间:DNS 预解析、TCP 预连接、利用 CDN 加速内容分发、启用 HTTP2 或 HTTP3、对资源进行压缩和缓存、优化关键渲染路径等等，这些共同决定了最终的用户体验。 详细分析1. URL 解析 浏览器会解析你输入的 URL，提取出协议（HTTPHTTPS）、主机名（例如 www.example.com）、路径（例如/path/to/resource）等信息。 2. DNS 解析如果主机名是一个域名而不是 IP 地址，浏览器会执行 DNS 解析，将域名解析为对应的 IP 地址。这通常涉及向 DNS 服务器发送查询请求，获取到对应的 IP 地址。 DNS 是什么DNS（Domain Name System，域名系统）是互联网中用于将域名（如 example.com）转换为相应 IP 地址的分布式命名系统。它充当了互联网上域名和 IP 地址之间的映射关系数据库。 DNS 解析DNS 解析是指将域名解析成相应的 IP 地址的过程。当你在浏览器中输入一个域名时，例如 www.example.com，浏览器首先需要将这个域名解析为对应的 IP 地址，才能向服务器发送请求。DNS 解析的过程如下： 浏览器缓存 浏览器会首先检查自己的 DNS 缓存，看是否已经解析过这个域名。如果之前已经解析过，并且缓存未过期，浏览器会直接使用缓存中的 IP 地址，无需进行 DNS 查询。 操作系统缓存 如果浏览器缓存中没有找到对应的记录，浏览器会检查操作系统的 DNS 缓存。操作系统也会缓存之前解析过的域名和 IP 地址，以提高解析效率。 本地 DNS 解析器 如果在操作系统缓存中也没有找到对应的记录，浏览器会向本地 DNS 解析器发起查询请求。通常，本地 DNS 解析器由你的 ISP（互联网服务提供商）或者其他网络服务提供商提供。本地 DNS 解析器会首先查看自己的缓存，如果有相应的记录，则返回 IP 地址；否则，它会向根域名服务器发起查询请求。 递归查询 如果本地 DNS 解析器在缓存中没有找到对应的记录，它会向根域名服务器发送递归查询请求。根域名服务器复杂存储顶级域名服务器（如.com、.org、.net 等）的 IP 地址。根域名服务器会返回顶级域名服务器的 IP 地址给本地 DNS 解析器。 迭代查询 本地 DNS 解析器收到顶级域名服务器的 IP 地址后，会向顶级域名服务器发起迭代查询请求，询问下一级域名服务器的 IP 地址。例如，如果要解析的域名是www.example.com,那么顶级域名服务器会返回.com域的权威域名服务器的IP地址。 权威域名服务器查询 本地 DNS 解析器收到权威域名服务器的 IP 地址后，会向权威域名服务器发起查询请求，获取要解析域名的具体 IP 地址。例如，权威域名服务器会返回 www.example.com 的 IP 地址给本地 DNS 解析器。 返回解析结果 本地 DNS 解析器收到 IP 地址后，会将结果返回给浏览器，浏览器会将这个 IP 地址用于建立 TCP 连接，并向服务器发送请求。 3. 建立 TCP 连接浏览器通过 IP 地址和端口号（默认 HTTP 的端口是 80，HTTPS 的端口是 443）与服务器建立 TCP 连接。这个过程中会进行三次握手以确立连接。 4. 发起 HTTP 请求一旦建立了 TCP 连接，浏览器就会发送一个 HTTP 请求到服务器。这个请求包含了之前解析得到的 URL 中的信息，例如主机名、路径等，以及其他的请求头部信息（如用户代理、cookie 等）。 5. 服务器处理请求服务器收到请求后，会根据请求的内容进行处理，可能会访问数据库、执行后端代码等操作，然后生成一个 HTTP 响应。 6. 返回 HTTP 响应服务器会将生成的 HTTP 响应发送回浏览器。这个响应包括一个状态码（例如 200 表示成功，404 表示未找到资源等）、响应头部（包含内容类型、内容长度等信息），以及响应体（实际的内容）。 7. 浏览器处理响应浏览器收到响应后，会根据响应的内容进行相应的处理。这可能涉及渲染 HTML、执行 JavaScript、应用 CSS 样式等操作。 浏览器会根据响应头部中的内容类型（Content-Type）来确定如何处理响应体。常见的内容类型包括： texthtml：HTML 文档。 textcss：CSS 样式表。 applicationjavascript：JavaScript 文件。 imagepng、imagejpeg：图片文件等。如果是 HTML 文档，浏览器会将其解析成 DOM 树，并开始渲染页面；如果是 CSS 文件，浏览器会应用样式；如果是 JavaScript 文件，浏览器会执行其中的脚本代码等等。 一旦浏览器解析了 HTML 文档并构建了 DOM 树，它会开始渲染页面。这个过程包括: 根据 DOM 树和 CSS 样式计算每个元素的大小、位置等属性。 将元素布局到页面上的正确位置。 将元素绘制到屏幕上 在渲染过程中，浏览器还会处理 JavaScript 代码的执行、事件绑定等操作。 8. 显示页面最后，浏览器会根据响应的内容将页面呈现给用户，在用户界面中显示网页内容。","tags":["浏览器"],"categories":["性能优化"]},{"title":"实时消息推送的方案","path":"/2024/05/27/message-push/","content":"轮询（不适于频繁请求的场景） 长轮询 前端发起请求，获取最新的消息，后端不会响应，除非有最新消息，再响应前端会出现线程堆积，造成服务器压力过大 短轮询 隔一段时间就发送请求，以便获取最新的消息，造成资源浪费， SSE(Server-Sent Events)SSE 是一种单向的、持久的连接前端发请求，建立一个长链接，服务端会持续向客户端发送响应，这是 HTTP 自带的功能。只能实现服务器到客户端的单向推送。（在线聊天、实时监控、新闻天气推送） WebSocket能够在客户端和服务器之间建立即时的通信连接。通过 WebSocket，服务器可以主动向客户端推送消息，而无需客户端主动请求。这种方案具有实时性好、性能高等优势，适用于大规模的实时推送场景。 netty 就是基于 websocket 封装的实时通信框架 MQTT发布-订阅模式的传输协议，针对于物联网，适用于资源受限的设备和低带宽，高延迟或不稳定的网络环境，","tags":["web"]},{"title":"前端性能优化","path":"/2024/05/19/performance-optimization/","content":"什么是 web 性能？MDN 上的 web 性能定义： Web 性能是网站或应用程序的客观度量和可感知的用户体验。 减少整体加载时间： 减少文件体积、减少 HTTP 请求、使用预加载 使得网站尽快可用：仅加载首屏内容，其他内容根据需要进行懒加载 平滑和交互性：使用 CSS 替代 JS 动画、减少 UI 重绘 感知表现：你的页面可能不难做到更快，但你可以让用户感觉更快。耗时操作要给用户反馈，比如加载动画、进度条、骨架屏等提示信息 性能测定：性能指标、性能测试、性能监控持续优化 如何进行 Web 性能优化？ 首先需要了解性能指标 - 多快才算快？ 使用专业的工具可量化的评估出网站或应用的性能表现 然后立足于网站页面响应的生命周期，分析出造成较差性能表现的原因 最后进行技术改造、可行性分析等具体的优化实践 迭代优化 指标RAIL 性能模型R（Response） - 尽快响应用户，应该在 100ms 内快速响应用户输入A（Animation）- 在展示动画的时候，每一帧应该以 16ms 进行响应，避免卡顿I（Idle）- 当使用 JS 主线程的时候，应该把任务划分到执行时间小于 50ms 的片段中去，这样可以释放线程以进行用户交互L（Load）- 应该在小于 1S 的时间内加载完成你的网站，并进行用户交互 基于用户体验的性能指标FCP （First Contentful Paint） 首次内容绘制浏览器首次绘制来自 DOM 的内容的时间，内容必须是文本、图片（包含背景图）、非白色的 canvas 或 svg，也包括带有正在加载中的 web 字体的文本。 白屏时间在 0-2 秒，属于快速，2-4 秒是中等，超过 4 属于慢。 LCP （ Largest Contentful Paint） 最大内容绘制可视区域中最大的内容元素呈现到屏幕上的时间，用以估算页面的主要内容对用户可见时间。 网站应力争使用 2.5 秒或更短的“最大内容绘画”，2.5 - 4 秒是中等，超过 4S 是慢。 FID（ First Input Delay） 首次输入延迟从用户第一次与页面交互（例如单击链接、点击按钮等）到浏览器实际能够响应应该交互的时间输入延迟是因为浏览器的主线程正忙于做其他事情，所以不能响应用户。发生这种情况的一个常见原因是浏览器正忙于解析和执行应用程序加载的大量计算的 JS。 100ms 内是快，100-300ms 是中等，大于 300ms 是慢 TTI (Time to Interactive)网页第一次完成达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。完全达到可交互状态的时间点是在最后一个长任务完成的时间，并且在随后的 5 秒内网络和主线程是空闲的。 超过 50ms 的任务是长任务，0-3.8 是快，3.9-7.3S 是中等，7.3S 以上是慢。 TBT (Total Block Time) 总阻塞时间度量 FCP 和 TTI 之间的总时间。 0-300：快； 300-600：中等； 600：慢 CLS （Cumulative Layout Shift） 累计布局偏移CLS 会测量在页面整个生命周期中发生的每个意外的布局移位的所有单独布局移位分数的总和，它是一种保证页面的视觉稳定性从而提升用户体验的指标方案。 0-0.1：快； 0.1-0.25： 中等； 0.25：慢 Web VitalsWeb Vitals 是一组统一的质量衡量指标 - Core Web Vitals,其中包括加载体验、交互性和页面内容的视觉稳定性。这是 Google 提出的，可以节省学习成本和时间，不需要学习其他诸多的指标。 将其他很多性能指标简化成这三个指标： FCP、LID、CLS web 性能测试灯塔 Lighthouse可以打开浏览器开发者工具调试，会给出分数，分析报告，和推荐解决方案。这个分数不一定准确，有时候受网络和硬件设备影响，并且要设置清除缓存。 WebPageTest是一个在线网站测试工具，https://www.webpagetest.org/。输入网站网址，在云端测试，支持多地区、浏览器、设备测试，可以设置网络速度，分辨率、测试次数等等，会给出一个很详细的报告。 Chrome DevTool前端页面的生命周期如何缩短首屏速度？效果比较好的操作 减少首屏资源体积 打包工具的压缩 异步加载（分析能够异步加载的，比较体积大，但又不是马上需要的功能，和首屏渲染没关系） 更新为体积更小的新版本（把一些老版本的库替换成新版本的支持 tree-shaking） 编写代码尽量减少体积 去除大的 base64 体积（打包工具默认将图片转成 base64，小图片可以转，但是 大图片和媒体资源 建议不要转成 base64） 能不用第三方库就不用第三方库（eg:时间格式化） 效果不太好或者在特殊情况下的优化操作 首屏数据尽量并行，如果可行让小数据量接口合并到其他接口 页面包含大量 dom 可以分批随滚动渲染 骨架屏，loading，先让屏幕不白，减少用户焦虑 操作速度和渲染速度什么情况下会造成操作卡顿和渲染慢？ 1. 一次性 操作大量长列表渲染和异步渲染 长列表渲染 虚拟化列表技术只渲染可见区域的数据项，而不是渲染整个列表 分页加载将长列表分割成多个页面，一次性只加载当前页面的数据，而不是全部数据。当用户滚动或者翻页时，再加载下一页的数据 使用列表项重用保持列表项的可重用性，避免频繁地创建和销毁 DOM 元素。这可以通过使用列表项池来维护已渲染的列表项，然后根据需要更新其内容。 异步渲染1. prefetch 加载假设 page1,page2 是同步加载，page3 是异步加载（prefetch）,首屏打开都会给这个三个创建 link 标签加载，但是没用标记 prefetch 的 link 会先加载，然后首屏展示完之后，再加载 prefetch 资源 const routes = [ path: /, name: Home, component: Home, , path: /about, name: About, component: () = return import(../views/About.vue); , ,]; 如果将网速调慢， 从 network 中也可以看出来，虽然先创建了 about.js 请求，但是需要等其他的请求完成之后再加载的 about 2. script 加载App.js（page1,page2）-首页加载完成-进入 page3-执行 js，创建一个 script 标签引入 page3 相关 js-page3.js-page3 页面看到 prefetch 和 script 加载 对比：script 加载: 做到了充分按需引入，用到的时候在加载，不用永不加载，充分节省了带宽 最大问题是，切换需要等待，体验不是很流畅 prefetch 加载: 充分利用使用者不占用带宽的浏览时间，切换到异步加载的页面是可能早已经加载好的，用户体验更流畅 一些本次行为不会打开的页面也会加载，一定程度上浪费了带宽 优化 按需引入 import read, utils from xlsx 一些非马上使用的操作，改成异步 change() import(jquery).then(res= let $=res.default let a =$(.test) a.html(hello) ) 3. 利用 setTimeout 或 requestAnimationFrame在渲染大量数据时，可以使用 setTimeout 或 requestAnimationFrame 来将渲染任务分解成多个小任务，并给浏览器一些空闲时间来处理其他任务，从而减少卡顿和提高渲染性能。 4. 使用 Web Workers可以将一些耗时的计算或处理任务放在 Web Workers 中进行，以避免阻塞主线程，从而提高页面的响应性能 5. 懒加载对于某些不是立即需要的数据或组件，可以延迟加载，直到用户需要时再进行加载和渲染。这可以通过 React 中的 React.lazy() 和 Vue 中的 vue-router 的懒加载功能来实现。 6. 使用分片加载对于大型数据集，可以将数据分成多个片段进行加载，并在每个片段加载完成后进行渲染。这样可以降低单次操作的负担，提高渲染的效率 2. 进行了复杂度高的运算（eg:循环）循环中操作尽量精简（可能效果不明显） 3. vue 和 react 项目中，不必要的渲染太多vuevue 中有依赖收集， 配合上 vue3 的静态节点标记，已经基本上避免了因为数据改变引起的无意义渲染 频繁切换的显隐内容用 v-show 也就是 display 来控制隐藏，只有打开就一次性决定显示与否的用 v-if 不去创建 循环，动态切换内容加好 key 值 keep-alive 缓存 区分请求粒度，减少请求范围，也能减少更新 react PureComponent 或 React.memo来减少不必要的重新渲染 通过实现shouldComponentUpdate生命周期方法来手动控制是否进行组件重新渲染。 避免在render方法中直接修改 state 或 props，因为这会触发组件的重新渲染。而是应该使用setState来更新state。 避免在渲染函数中执行昂贵的操作，例如大量计算、数据请求等，这会影响渲染性能。可以将这些操作移到生命周期方法中，或者使用异步渲染技术进行优化。 数据缓存 不变数据，定期时效可以缓存在 cookies 或者 localStorage 中，比如 token,用户名 可以考虑做一个缓存队列，存于内存中（全局对象，vuex）。这样能保证刷新就更新数据，也能一定程度上缓存数据","tags":["性能优化"],"categories":["性能优化"]},{"title":"JS实现贪吃蛇游戏","path":"/2024/03/31/snake/","content":"设计 规则 贪吃蛇初始为 1 点，可通过上、下、左、右键控制方向移动 每吃一个食物分数+1，每吃 10 个食物，等级+1，每升一级，速度 + 20ms 贪吃虫不能撞墙和自己，否则游戏失败 每吃掉一个食物，贪吃蛇长度+1，下一个食物会在随机位置出现。 实现HTMLdiv id=main div id=stage div id=snake div/div /div div id=food div class=/div div class=/div div class=/div div class=/div /div /div div id=info div class=SCORE: span id=score0/span/div div class=LEVEL: span id=level1/span/div /div/div JSconst snake = document.getElementById(snake);const snakes = snake.getElementsByTagName(div);const food = document.querySelector(#food);const scoreElement = document.getElementById(score);const levelElement = document.getElementById(level);let dir, keyActive = true, gaveOver = false, level = 1, score = 0, speed = 300;const keyArr = [ArrowUp, ArrowDown, ArrowRight, ArrowLeft];const dirObj = ArrowUp: ArrowDown, ArrowDown: ArrowUp, ArrowRight: ArrowLeft, ArrowLeft: ArrowRight,;// 监听键盘事件， 保存方向document.addEventListener(keydown, (e) = if ( keyActive //只监听上下左右方向 keyArr.includes(e.key) //不能反方向，除非蛇的长度等于1 (snakes.length 2 || dirObj[dir] !== e.key) ) dir = e.key; keyActive = false; );function changeFood() // 获取0-29之间的随机数，然后*10，即0-290 const x = Math.floor(Math.random() * 30) * 10; const y = Math.floor(Math.random() * 30) * 10; food.style.top = y + px; food.style.left = x + px;setTimeout(function move() const head = snakes[0]; let y = head.offsetTop, x = head.offsetLeft; switch (dir) case ArrowUp: y -= 10; break; case ArrowDown: y += 10; break; case ArrowRight: x += 10; break; case ArrowLeft: x -= 10; break; //如果食物坐标和头部坐标相吻合，说明蛇吃到了食物，然后改变食物的坐标到新的随机坐标，并把蛇长度+1，分数+1，如果此时满10个了，等级再+1，速度提升20ms if ( food.offsetTop === head.offsetTop food.offsetLeft === head.offsetLeft ) changeFood(); snake.insertAdjacentHTML(beforeend, div/); score++; scoreElement.textContent = score; if (score % 10 === 0 level 14) level++; levelElement.textContent = level; speed = speed - level * 20; //撞墙或撞自己就死了 if (x 0 || x 290 || y 0 || y 290) alert(`撞墙了，游戏结束！ 您的分数为$score分`); return; if (snakes.length 1) for (let i = 0; i snakes.length - 1; i++) if (snakes[i].offsetTop === y snakes[i].offsetLeft === x) alert(`撞自己了，游戏结束！ 您的分数为$score分`); return; //蛇的移动：蛇的尾部挪到蛇的头部，就可以实现代价最小的移动， const tail = snakes[snakes.length - 1]; tail.style.left = x + px; tail.style.top = y + px; snake.insertAdjacentElement(afterbegin, tail); keyActive = true; setTimeout(move, speed);, speed); CSS* margin: 0; padding: 0; box-sizing: border-box;#main width: 360px; height: 420px; border: 10px solid #000; background-color: #b7d4a8; border-radius: 20px; margin: 50px auto;#stage width: 304px; height: 304px; border: 2px solid #000; margin: 20px auto; position: relative;#snake div width: 10px; height: 10px; background-color: #000; position: absolute; border: 1px solid #b7d4a8;#food width: 10px; height: 10px; position: absolute; display: flex; flex-wrap: wrap; top: 100px; left: 120px;#food div width: 5px; height: 5px; background-color: #000; transform: rotate(45deg);#info width: 304px; margin: 0 auto; display: flex; justify-content: space-between; font: bold 20px courier;","tags":["JS"]},{"title":"pnpm","path":"/2024/03/19/pnpm/","content":"pnpm(performant npm) 通过软、硬链接（hark link、symbolic link） + 全局存储（store）结合的依赖管理方式完全实现了依赖树结构的包管理方式，解决了 npm3 及 yarn 中的幽灵依赖和 npm 分身的问题，提升了依赖包的安装速度，减小了磁盘空间占用。 pnpm 为何节省空间它解决了 npmyarn 平铺 node_modules 带来的依赖项重复的问题 (doppelgangers) 假设存在依赖依赖: .├── package-a│ └── lodash@4.0.0├── package-b│ └── lodash@4.0.0├── package-c│ └── lodash@3.0.0└── package-d └── lodash@3.0.0 那么不可避免地在 npm 或者 yarn 中，lodash@3.0.0 会被多次安装，无疑造成了空间的浪费与诸多问题。 ./node_modules/lodash./node_modules/package-a./node_modules/package-b./node_modules/package-c./node_modules/package-c/node_mdoules/lodash./node_modules/package-d./node_modules/package-d/node_mdoules/lodash 这是一个较为常见的场景，在平时项目中有些库相同版本甚至会安装七八次，如 postcss、ansi-styles、ansi-regex、braces 等，可以去yarn.lock/package-lock.json 中搜索一下。 而在 pnpm 中，它改变了 npmyarn 的目录结构，采用软链接的方式，避免了 doppelgangers 问题更加节省空间。 它最终生成的 node_modules 如下所示，从中也可以看出它解决了幽灵依赖的问题。 ./node_modules/package-a - .pnpm/package-a@1.0.0/node_modules/package-a./node_modules/package-b - .pnpm/package-b@1.0.0/node_modules/package-b./node_modules/package-c - .pnpm/package-c@1.0.0/node_modules/package-c./node_modules/package-d - .pnpm/package-d@1.0.0/node_modules/package-d./node_modules/.pnpm/lodash@3.0.0./node_modules/.pnpm/lodash@4.0.0./node_modules/.pnpm/package-a@1.0.0./node_modules/.pnpm/package-a@1.0.0/node_modules/package-a./node_modules/.pnpm/package-a@1.0.0/node_modules/lodash - .pnpm/package-a@1.0.0/node_modules/lodash@4.0.0./node_modules/.pnpm/package-b@1.0.0./node_modules/.pnpm/package-b@1.0.0/node_modules/package-b./node_modules/.pnpm/package-b@1.0.0/node_modules/lodash - .pnpm/package-b@1.0.0/node_modules/lodash@4.0.0./node_modules/.pnpm/package-c@1.0.0./node_modules/.pnpm/package-c@1.0.0/node_modules/package-c./node_modules/.pnpm/package-c@1.0.0/node_modules/lodash - .pnpm/package-c@1.0.0/node_modules/lodash@3.0.0./node_modules/.pnpm/package-d@1.0.0./node_modules/.pnpm/package-d@1.0.0/node_modules/package-d./node_modules/.pnpm/package-d@1.0.0/node_modules/lodash - .pnpm/package-d@1.0.0/node_modules/lodash@3.0.0 如此，依赖软链接的方式，可解决重复依赖安装 (doppelgangers) 的问题，如果一个项目占用 1000 MB，那么使用 pnpm 可能仅占用 800 MB 然而它除此之外，还有一个最大的好处，如果一个项目占用 1000 MB，传统方式十个项目占用 10000 MB，那么使用 pnpm 可能仅占用 3000 MB，而它得益于硬链接。 再借用以上示例，lodash@3.0.0 与 lodash@4.0.0 会生成一个指向全局目录(~/.pnpm-store)的硬链接，如果新项目依赖二者，则可复用存储空间。 ./node_modules/.pnpm/lodash@3.0.0/node_modules/lodash - hardlink./node_modules/.pnpm/lodash@4.0.0/node_modules/lodash - hardlink pnpm、yarn、npm 的区别 功能 pnpm yarn npm 工作空间支持（monorepo） O O O 隔离的 node_modules O-默认 O O 提升的 node_modules O O O-默认 自动安装 peers O X O Plug’n’Play O O-默认 X 零安装 X O X 修补依赖项 O O X 管理 Node.js 版本 O X X 有锁文件 O-pnpm-lock.yaml O-yarn.lock O-package-lock.json 支持覆盖 O O-通过 resolutions O 内容可寻址存储 O X X 动态包执行 O-通过 pnpm dlx O-通过 yarn dlx O-通过 npx Side-effects cache O X X Listing License O-Vua pnpm licenses list O-Via a plugin X 安装和使用npm install -g pnpmpnpm -v//使用pnpm initpnpm install xxxpnpm run xxx //设置源pnpm config get registrypnpm config set registry 淘宝源或其他源地址//管理依赖pnpm add xxxpnpm add -D xxx //安装到devDependenciespnpm add -O xxx //安装到optionalDependenciespnpm add -g xx //全局安装依赖包pnpm install 或(pnpm i)pnpm update 或( pnpm up)pnpm remove 或(pnpm rm/uninstall/un) 查看依赖pnpm list 或(pnpm ls)pnpm list --global 或(pnpm ls --g)pnpm outdated //检查过期的依赖 运行脚本pnpm run xxx 或（pnpm xxx）pnpm test 运行test测试脚本pnpm createpnpm start 包存储 storepnpm store: pnpm 资源在磁盘上的存储空间 可以通过 pnpm store path命令查看 store 存储目录的路径 在项目中执行pnpm install的时候，依赖包存在于 store 中，直接创建依赖包硬链接到 store 中，如果不存在，则从远程下载后存储在 store 中，并从项目的 node_modules 依赖包中创建硬链接到 store 中。 pnpm store prune，从存储中删除未引用的包。 workspce 协议 workspce:工作空间 workspace:*协议，表示依赖的就一直是本地的包，而不是从npm registry安装的包。 别名引用假如工作区有一个名为 foo 的包，可以通过这样引用 foo: workspace:，如果是其它别名，可以这么引用：bar: workspace:foo@*。 相对引用假如 packages 下有同层级的 foo、bar，其中 bar 依赖于 foo，则可以写作bar: workspace:../foo。 发布 workspace 包当 workspace 包打包发布时，将会动态替换这些 workspace:依赖。 npm 或 Yarn 转 pnpm操作步骤： 全局安装 pnpm npm install -g pnpm 删除 npm 或 yarn 生成的 node_modules # 项目目录下运行或手动物理删除rm -rf node_modules pnpm import 从其他软件包管理器的 lock 文件生成 pnpm-lock.yaml，再执行 pnpm install --frozen-lockfile（相当于 npm ci）生成依赖，防止没有 lock 文件意外升级依赖包，导致项目出错 # 生成`pnpm-lock.yaml`pnpm import# 安装依赖pnpm install --frozen-lockfile 删除 npm 或 yarn 生成的 lock 文件 # 删除 package-lock.jsonrm -rf package-lock.json# 删除 yarn.lockrm -rf yarn.lock 项目中的 npm 命令等修改为 pnpm，包括 README 文档、运行命令等 参考链接","tags":["pnpm"]},{"title":"vmin和vw","path":"/2024/03/18/vmin/","content":"vwvh 和 vminvmaxvmin 可以照顾手机端 横屏和竖屏 的显示效果 vwvhvh 和 vw 与视口的宽度和高度有关1vw 就是视口宽度的 1% vminvmaxvmin 和 vmax 是与当下屏幕的宽度和高度的最大值或最小值有关，取决于哪个更大和更小。 app /* width: 100vw; */ width: 100vmin; vim: 当前 vw 和 vh 中较小的一个值(即相对于视窗中较短的一边) vmax: 当前 vw 和 vh 中较大的一个值(即相对于视窗中较长的一边)","tags":["CSS"]},{"title":"算法可视化网站分享","path":"/2024/03/18/algorithm-share/","content":"通过动画可视化数据结构和算法: https://visualgo.net/zh 网站里面包含了排序、链表、哈希表、二叉搜索树、递归树、循环查找等常见算法动画，而部分高级算法，现今也只能在 VisuAlgo 上找到具体的动画展示效果。 我们可以定义自己的输入，可以切换模式：探索模式和电子讲座模式，也可以暂停和播放动画展示，也可以调整速度，网站也对每个步骤算法进行说明。 不仅于此，该网站还提供了一些算法练习题供学生训练，以便更进一步巩固自己的算法知识。","tags":["算法"]},{"title":"Asset Modules资源模块","path":"/2024/03/10/asset-module/","content":"Asset Modules 资源模块，针对于图片字体等这一类型的文件模块，无须额外的预处理器，webpack 可以通过一些配置完成对它们的解析，这是 webpack5 新加入的，和 file-loader,raw-loader,url-loader 预处理器功能相似 typeAsset Modules 类型通过添加 4 个新的模块 type 来取代所有这些 loader assetresource 发出一个单独的文件并导出 URL。和 file-loader 类似 assetinline 和 url-loader相似，处理文件导入地址并将其替换成 data URL,默认是 Base64 格式编码的 URL assetsource 和raw-loader很像，以字符串形式导出文件资源 asset 在导出单独的文件 和 data URL 间自动选择，可以通过修改配置项影响自动选择的标准 democonst path = require(path);module.exports = entry: ./a.js, output: path: path.resolve(__dirname, ), filename: bundle.js, , module: rules: [ test: /\\.jpg$/, type: asset/resource, , ], , mode: none,; 打包入口文件是a.jsa.js 文件内容： import img from ./sky.jpg;console.log(img);var dom = `img src=$img /`;window.onload = function () document.getElementById(main).innerHTML = dom;; 打包后目录里生成6d99f3aefcfa4bj41a7f.jpg,这个是 sky.jpg 被 assetresource 处理后生成的。 自定义文件名称1. 通过 generator.filename 配置module: rules: [ test: /\\.jpg$/, type: asset/resource, generator: filename: static/[hash:8][ext][query] //8位hash值与后缀名的组合 ], 2. 在 output 里配置module.exports = entry: ./a.js, output: path: path.resolve(__dirname, ), filename: bundle.js, assetModuleFilename: static/[hash:6][ext][query], , module: rules: [ test: /\\.jpg$/, type: asset/resource, , ], , mode: none,; 这两种方式配置资源文件名称的效果是一样，并且只能用于 type 是 asset 和 asset/resource 的情况 assetinline打包后文件目录没有新增图片，原始图片被处理成 Base64 编码的 data URL 并直接存放在打包生成的 bundle.js 文件里 dataURL 默认使用 Base64 编码，可以配置 generator.dataURL 进行自定义编码算法。 assetwebpack 默认对于大于 8 KB 的资源 以 assetresource 处理，否则以 assetinline 处理 但是我们也可以修改这个资源大小的阙值，在 module.rule 的 parser.dataURLCondition.maxSize 中配置. const path = require(path);module.exports = entry: ./a.js, output: path: path.resolve(__dirname, ), filename: bundle.js, , module: rules: [ test: /\\.(jpg|png)$/, type: asset, parser: dataUrlCondition: maxSize: 6 * 1024, // 6kb , , , ], , mode: none,; Asset Modules 虽然可以代替部分预处理器的功能，但是要进行个性化配置的时候还是使用预处理器更方便。比如，目前如果要给预处理器配置 publicPath，目前是做不到，而且 Asset Modules 存在 BUG，还需要修复。 但是 Asset Modules 是 webpack 的未来，文件资源预处理器后续已经不进行维护了，随着 Asset Modules 功能的优化，未来可能会取代 file-loader 等预处理器，我们需要留意 Asset Modules 的最新状态","tags":["webpack"],"categories":["前端工程化"]},{"title":"vue2和vue3的区别","path":"/2024/02/26/vue2-vue3/","content":"性能优化Vue 3 在性能方面有显著提升。它引入了一个全新的虚拟 DOM 算法（Faster Virtual DOM），该算法使用了更有效的数据结构和算法，使得在渲染大型组件树时更快速。另外，Vue 3 还引入了静态树提升（Static Tree Hoisting）技术，通过在编译阶段将静态部分的节点提升为常量，进一步减少了运行时的开销。 虚拟 DOM 算法 1. 片段（Fragment）和合并（Patch）：Vue 3 引入了 Fragment 的概念，它将组件的模板划分为多个小片段。这样一来，在更新时可以只更新发生变化的部分，而不需要重新渲染整个组件。这种局部更新的机制可以大大提高渲染性能。Patch 是 Vue 3 中的一个关键概念，用于将虚拟 DOM 节点的变化应用到实际的 DOM 上。Vue 3 通过对比新旧虚拟 DOM 树的差异，并将这些差异应用到实际的 DOM 上，来完成更新操作。 2. 静态树提升（Static Tree Hoisting）：静态树提升是 Vue 3 的一个优化技术，它允许编译器在编译时识别出组件模板中的静态部分，并将其提升为常量。这样一来，每次渲染时都不需要重新计算静态部分，从而减少了渲染的开销。静态树提升使得 Vue 3 在处理静态内容时能够更快地完成渲染，尤其是对于大型组件树的渲染效率提升尤为显著。 3. 事件侦听器的优化：在 Vue 3 中，事件侦听器的绑定和解绑过程得到了优化，使得事件处理的性能得到提升。Vue 3 使用更有效的数据结构来管理事件侦听器，减少了事件绑定和解绑的开销。这种优化使得在频繁触发事件的情况下，Vue 3 的性能表现更好，同时也降低了内存的占用。 4. 批量更新：Vue 3 引入了批量更新机制，通过将多个更新操作合并成一个更新批次来减少渲染的次数。这样可以避免不必要的重复渲染，提高了渲染效率。批量更新机制还可以降低触发重排和重绘的次数，从而减少了浏览器的性能开销，提升了整体的渲染性能。 Composition APIVue 3 引入了 Composition API，这是一个基于函数的 API，允许开发者根据逻辑功能组织代码，而不是像 Vue 2 中的 Options API 那样基于选项的组件定义。Composition API 更加灵活，使得代码复用和组件逻辑的组织更加清晰。 Composition API 和 Options API1. Options APIOptions API 是 Vue 2.x 中默认使用的 API。它通过将组件的选项（options）放置在一个对象中来组织组件的逻辑。这些选项可以包括 data、methods、computed、watch 等。 Options API 适合于较小规模的组件或者简单的应用程序。通过将相关的逻辑放置在对应的选项中，使得组件的结构相对清晰，易于理解和维护。 Options API 的缺点在于，当组件变得较大或者复杂时，所有的选项都放在一个对象中会导致代码结构变得混乱，不易于复用和组织。 2. Composition APIComposition API 是 Vue 3.x 中引入的一种新的 API。它通过使用函数来组织和管理组件的逻辑，使得代码更加灵活和可组合。Composition API 允许开发者将组件的逻辑代码按照功能划分为多个函数，然后通过在组件中使用这些函数来组装组件的逻辑。这样一来，可以更自然地组织和复用代码，使得组件的结构更清晰。Composition API 提供了更多的灵活性，使得开发者可以更轻松地处理复杂的逻辑需求。它也更适合于跨组件共享逻辑或者在不同组件之间进行代码复用。 Tree-shaking 支持Vue 3 对 Tree-shaking 有更好的支持。通过对模块的静态分析，Vue 3 可以更有效地移除未使用的代码，从而减小最终构建产物的大小。 TypeScript 支持Vue 3 对 TypeScript 的支持更加完善。它提供了更全面和精确的类型定义，使得在使用 TypeScript 开发 Vue 应用时更加顺畅。 原先 vue2 中 对 javascript 使用 flow 进行类型检测 响应性系统重构Vue 3 对其响应性系统进行了重构，使其更为强大和高效。Vue 3 采用了 Proxy 来实现响应式，相比 Vue 2 中的 Object.defineProperty，Proxy 具有更好的性能和更灵活的用法。 1. Object.definePropertyObject.defineProperty 是 ES5 中引入的一种对象属性定义方法，用于直接在一个对象上定义一个新属性，或者修改一个已经存在的属性。它通过定义属性的 get 和 set 方法来实现对属性的拦截和代理。通过这种方式，可以在属性被读取或者赋值时执行一些自定义的逻辑。Object.defineProperty 是针对单个属性进行操作的，需要针对每个需要代理的属性分别定义，相对来说比较繁琐。 2. ProxyProxy 是 ES6 中引入的一种全新的代理机制，它提供了一种通用的方法来拦截对象的操作，并且可以对整个对象进行代理，而不是针对单个属性。通过 Proxy，可以拦截对象的诸多操作，包括属性的读取、赋值、删除等。它提供了一系列的拦截方法，比如 get、set、deleteProperty 等。Proxy 是一种更加灵活和强大的代理机制，相比于 Object.defineProperty，它可以更方便地实现对整个对象的代理，并且可以对所有属性进行统一的处理。 Object.defineProperty 主要用于对单个属性进行拦截和代理，而 Proxy 则是一种更为通用和强大的代理机制，可以对整个对象进行代理，并且提供了更多的拦截方法。在现代的 JavaScript 开发中，通常推荐使用 Proxy 来实现对象的拦截和代理，因为它提供了更多的功能和更灵活的使用方式。 TeleportVue 3 引入了 Teleport 特性，这是一种可以将子组件的内容渲染到父组件的指定DOM 位置的机制。Teleport 可以用于实现模态框、弹出菜单等组件，使得它们的位置更加灵活。 template div button @click=toggleModalToggle Modal/button teleport to=body modal v-if=showModal / /teleport /div/templatescriptimport ref from vue;import Modal from ./Modal.vue;export default components: Modal, , setup() const showModal = ref(false); const toggleModal = () = showModal.value = !showModal.value; ; return showModal, toggleModal, ; ,;/script 在上面的例子中，我们通过 Teleport 将 Modal 组件的内容传送到了 body 元素下，从而实现了模态框的渲染。 SuspenseVue 3 引入了 Suspense 特性，这是一种用于处理异步组件渲染的机制。开发者可以使用 Suspense 来优雅地处理组件加载过程中的加载状态，以及在组件加载失败时的错误处理。 template suspense template #default async-component / /template template #fallback divLoading.../div /template /suspense/templatescriptimport defineAsyncComponent from vue;const AsyncComponent = defineAsyncComponent(() = import(./AsyncComponent.vue));export default components: AsyncComponent, ,;/script 在上面的例子中，Suspense 包裹了一个异步组件AsyncComponent，并通过fallback插槽提供了一个加载状态的占位符。当异步组件加载时，会先显示 fallback 中的内容，直到异步组件加载完成后，才会显示 AsyncComponent 的内容","tags":["Vue"],"categories":["现代框架应用和原理剖析"]},{"title":"CI环境下的npm优化及工程化问题解析","path":"/2024/02/25/ci-npm/","content":"CI 环境下的 npm 优化CI 环境下的 npm 配置 和 本地环境下的 npm 操作有些许不同，我们首先来看看 CI 环境下的 npm 优化方法 1. 合理使用 npm ci 命令 和 npm install 命令顾名思义，npm ci 命令就是专门为 CI 环境准备的安装命令，相比于 npm install命令，它的不同之处有以下几点。 npm ci 命令要求项目中必须存在 package-lock.json 或 npm-shrinkwrap.json命令 npm ci 命令完全根据 package-lock.json 文件安装依赖，这样可以保证开发团队成员使用版本一致的依赖。 因为 npm ci 命令完全根据 package-lock.json 文件安装依赖，因此在安装过程中，它不需要求解依赖满足问题及构造依赖树，安装过程更加迅速。 npm ci 命令在执行安装时会先删除项目中现有的 node_modules 目录，重新安装。 npm ci 命令只能一次性安装项目中所有的依赖包，无法安装单个依赖包。 如果 package-lock.json 文件和 package.json 文件冲突，那么执行 npm ci 命令时会直接报错。 执行 npm ci 命令永远不会改变 package.json 和 package-lock.json 文件的内容。 基于以上特效，我们在 CI 环境下使用 npm ci 命令代替 npm install 命令时，一般会获得更加稳定、一致、迅速的安装体验 2. 使用 package-lock.json 文件缩短依赖安装时间项目中使用 package-lock.json 文件一般可以显著缩短依赖安装时间。这是因为 package-lock.json 文件中已经缓存了每个包的具体版本信息和下载链接，不要再去远程仓库进行查询即可直接进入文件完整性校验环节，减少大量网络请求。 除了以上内容之外，在 CI 环境下，缓存 node_modules 目录文件也是企业使用包管理工具常用的优化方法。 为什么有 xxxDependenciesnpm 设计了以下几种依赖类型声明 dependencies： 项目依赖 devDependencies： 开发依赖 peerDependencies： 同版本依赖 bundledDependencies： 捆绑依赖 optionalDependencies： 可选依赖 1.dependencies： 项目依赖这些依赖会成为线上生产环节中代码组成部分，当它关联的 npm 包会下载时，dependencies 下的模块也会作为依赖一起被下载。 2.devDependencies： 开发依赖不会自动下载，因为 devDependencies 一般只在开发阶段起作用，或只在开发环境中被用到。 如 webpack,预处理器 babel-loader、scss-loader,测试工具 E2E、Chai 等，这些都是辅助开发的工具包，无须在生产环境中使用。 并不是只有 dependencies 下的模块才会被一起打包，而 devDependencies 下的模块一定不会被打包。实际上，模块是否作为依赖被打包，完全取决于项目里是否引入了该模块。 3.peerDependencies： 同版本依赖简单来说： 如果你安装了我，最好你也安装我的依赖。 4.bundledDependencies： 捆绑依赖和 npm pack 打包命令有关。 name: test, version: 1.0.0, dependencies: dep: ^0.0.2 , devDependencies: devD1: ^0.0.2 , bundledDependencies: [bundleD1, bundleD1] 需要注意：bundledDependencies 中指定的依赖包必须先在 dependencies 和 devDependencies 中声明过，否则执行 npm pack 命令阶段会报错。 5.optionalDependencies： 可选依赖该依赖如果安装失败，也不会影响整个安装过程。一般很少使用它，也不建议使用，会增加项目的不确定性和复杂性。","categories":["前端质量保障"]},{"title":"webpack的热更新原理","path":"/2024/02/20/hot-module-replacement/","content":"Webpack 的热更新（Hot Module Replacement，HMR）是一种使得开发者在修改代码时，无需手动刷新浏览器页面即可立即查看到更新效果的技术。其原理如下： 启动 HMR 服务器：当你在 Webpack 配置中启用了热更新时，Webpack 会启动一个内置的 HMR 服务器，用于监听文件变化并通知浏览器进行更新。 监视文件变化：当你修改了一个文件并保存时，Webpack 会检测到文件的变化，并根据配置文件中的规则决定哪些模块需要进行热更新。 构建新模块：一旦 Webpack 确定了哪些模块需要更新，它会重新构建这些模块，并生成新的模块代码。 向浏览器发送更新通知：完成模块的重新构建后，Webpack 会将更新的模块代码通过 WebSocket 或者 XHR 等方式发送到浏览器端。 浏览器端更新模块：浏览器接收到更新的模块代码后，会利用 Webpack 的运行时环境（runtime）来替换对应的模块，从而实现页面的更新。Webpack 的运行时环境会自动地将新模块的代码注入到当前页面中，并更新相关的组件、样式等，同时保持页面的状态不变。 通过这种方式，Webpack 的热更新技术使得开发者可以在修改代码后立即查看到更新效果，无需手动刷新浏览器页面，提高了开发效率和体验。需要注意的是，热更新仅适用于开发环境，在生产环境中仍然需要手动刷新页面以获取最新的代码。","tags":["webpack"],"categories":["前端工程化"]},{"title":"模块化发展历程","path":"/2024/02/19/ModularDevelopmentHistory/","content":"模块化的发展历程经历了多个阶段，从早期的自执行函数（IIFE）到现代的 ES Module，每个阶段都在不断地解决代码组织、依赖管理和模块加载等问题。下面是模块化发展历程的简要介绍： 1. IIFE（立即执行函数）：在早期的 JavaScript 开发中，为了避免全局变量的污染和命名冲突，开发者经常使用自执行函数（Immediately Invoked Function Expression，IIFE）来创建一个独立的作用域，将代码封装起来，达到模块化的效果。但是这种方式并没有真正解决模块化的问题，只是通过作用域的隔离来减少了全局污染的风险。 // 使用IIFE创建模块(function () var privateVariable = I am private; function privateFunction() console.log(This is a private function); // 导出公共接口 window.MyModule = publicMethod: function () console.log(This is a public method); privateFunction(); , ;)(); 2. AMD（异步模块定义）：AMD 是由 RequireJS 提出的一种模块定义规范，它允许开发者异步加载模块，从而提高了页面的加载性能。AMD 规范定义了 define 函数用于定义模块，以及 require 函数用于加载模块。通过 AMD，开发者可以明确地声明模块之间的依赖关系，并在需要时异步加载这些依赖模块。 // 使用AMD定义模块define([dependency1, dependency2], function (dependency1, dependency2) var privateVariable = I am private; function privateFunction() console.log(This is a private function); // 导出公共接口 return publicMethod: function () console.log(This is a public method); privateFunction(); , ;); 3. CMD（通用模块定义）：CMD 是由 SeaJS 提出的一种模块定义规范，与 AMD 类似，但更加注重模块的延迟执行。CMD 规范定义了 define 函数用于定义模块，以及 require函数用于加载模块。相比于 AMD，CMD 更加倾向于将模块的加载放在模块内部，以便实现模块的按需加载。 // 使用CMD定义模块define(function (require, exports, module) var dependency1 = require(dependency1); var dependency2 = require(dependency2); var privateVariable = I am private; function privateFunction() console.log(This is a private function); // 导出公共接口 exports.publicMethod = function () console.log(This is a public method); privateFunction(); ;); 4. CommonJS：CommonJS 是一种服务器端模块的规范，最初是为 Node.js 设计的，后来也被广泛应用于前端开发中。CommonJS 规范定义了 require 函数用于加载模块，以及 module.exports 和 exports 对象用于导出模块。通过 CommonJS，开发者可以在 Node.js 环境下实现模块化的开发，并使用类似于服务器端的模块加载机制。 // 使用CommonJS定义模块var dependency1 = require(dependency1);var dependency2 = require(dependency2);var privateVariable = I am private;function privateFunction() console.log(This is a private function);// 导出公共接口module.exports = publicMethod: function () console.log(This is a public method); privateFunction(); ,; 5. UMD（通用模块定义）：UMD 是一种通用的模块定义规范，可以兼容 AMD、CMD 和 CommonJS 等多种模块加载机制。UMD 模块可以在浏览器端和 Node.js 环境下通用，使得开发者可以更灵活地选择适合自己项目的模块加载方式。 // 使用UMD定义模块(function (root, factory) if (typeof define === function define.amd) // AMD define([dependency1, dependency2], factory); else if (typeof exports === object) // CommonJS module.exports = factory(require(dependency1), require(dependency2)); else // 浏览器全局变量 root.MyModule = factory(root.dependency1, root.dependency2); )(this, function (dependency1, dependency2) var privateVariable = I am private; function privateFunction() console.log(This is a private function); // 导出公共接口 return publicMethod: function () console.log(This is a public method); privateFunction(); , ;); 6. webpack（require.ensure）：webpack 是一种现代化的模块打包工具，它支持多种模块化的规范，包括 CommonJS、AMD、ES Module 等。在 webpack 中，开发者可以使用 require.ensure 来实现按需加载模块，从而提高页面的加载性能。 // 在需要时动态加载模块function loadModule() require.ensure([./module], function (require) var module = require(./module); module.doSomething(); );// 主程序入口function main() // 加载模块 loadModule();// 启动主程序main(); 7. ES Module：ES Module 是 JavaScript 的官方模块化规范，从 ES6 开始被纳入到 JavaScript 的标准中。ES Module 允许开发者使用 import 和 export 语法来定义和导出模块，从而实现了原生的模块化开发。ES Module 在浏览器和 Node.js 环境下都得到了广泛的支持，并成为了现代 JavaScript 开发的主流模块化方式。 // 使用ES Module定义模块import dependency1 from dependency1;import dependency2 from dependency2;var privateVariable = I am private;function privateFunction() console.log(This is a private function);// 导出公共接口export function publicMethod() console.log(This is a public method); privateFunction(); 8. script type=module：HTML 的script type=module标签是浏览器原生支持的 ES Module 的加载方式。通过在 HTML 中直接使用这个标签，开发者可以加载并执行 ES Module，从而实现了在浏览器端的模块化开发。 !DOCTYPE htmlhtml lang=en head meta charset=UTF-8 / meta name=viewport content=width=device-width, initial-scale=1.0 / titleES Module Example/title /head body !-- 使用ES Module加载模块 -- script type=module import publicMethod from ./module.js; publicMethod(); /script /body/html","tags":["模块化"],"categories":["前端工程化"]},{"title":"Webpack的核心工作流程是怎样的?Loader 和 Plugin 的区别是什么? 如何提升 webpack 的构造性能?","path":"/2024/01/23/webpack/","content":"核心工作流程Webpack 作为一个强大的模块打包工具，其核心工作流程可以看作是一部精心编排的交响乐，而 Loader 和 Plugin则是其中的两大核心乐器。 整个流程始于一个或多个入口(Entry)文件。Webpack从入口出发，递归地解析代码中的 import 和require 语句，构建出一张包含所有模块及其相互关系的依赖图(Dependency Graph)。 loader在这个构建依赖图的过程中，Loader 扮演了翻译官的角色。Webpack 原生只理解 JavaScript 和 JSON 文件。当它遇到如.scss、.tsx、.png 等非 JavaScript 类型的文件时，就会查找匹配的 Loader。Loader 的职责就是将这些文件转换成 Webpack 能够理解和处理的有效模块。例如，babel-loader 将ES6+ 语法转译为 ES5，css-loader 解析 CSS 文件。Loader 的作用域是单个文件，它在模块加载的环节执行。 plugin当所有模块都被 Loader 成功“翻译”后，Plugin 便登上了舞台。Plugin 是架构师，它不直接操作单个文件，而是深入到 Webpack 编译的整个生命周期中。通过监听 Webpack广播出的事件钩子，Plugin 可以在打包过程的特定时刻执行广泛的任务，从而实现对打包结果的自定义和优化。比如,Htmlwebpackplugin 可以在打包结束后自动生成个 HTML 文件并注入打包好的脚本， TerserwebpackPlugin 则负责在最终输出前对代码进行压缩。 简而言之，Loader 负责内容的转换，Plugin 负责流程的扩展。前者是输入到输出的管道，后者是整个构建过程的控制器。 如何提升 webpack 的构造性能1. speed-measure-webpack-plugin优化你的 webpack 构建速度的第一步是要知道你应该把注意力集中在哪里，在这里推荐一个插件：speed-measure-webpack-plugin，这个插件可以测量你的 webpack 构建速度。 installnpm install --save-dev speed-measure-webpack-plugin or yarn add -D speed-measure-webpack-plugin 用法const webpackConfig = plugins: [new MyPlugin(), new MyOtherPlugin()],; to const SpeedMeasurePlugin = require(speed-measure-webpack-plugin);const smp = new SpeedMeasurePlugin();const webpackConfig = smp.wrap( plugins: [new MyPlugin(), new MyOtherPlugin()],); 2. 更快的 loader：swc在 webpack 中耗时最久的当属负责 AST 转换的 loader。我们可以使用速度更快的swc module: rules: [ test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: // Use `.swcrc` to configure swc loader: swc-loader, , , ]; 如何配置 swcSWC can be configured with an .swcrc file. this is Compilation 如果你是使用的 babel,swc 官方网站拥有提供从 babel 迁移到 swc 的指南 3. 持久化缓存：cachewebpack5 内置了关于缓存的插件，可以通过配置来开启，它将Module、Chunk、ModuleChunk等信息序列化到磁盘中，二次构建避免重复编译计算，编译速度得到很大的提升 cache: type: filesystem; 当开启了持久化缓存功能，最耗时的 AST 解析将能够从磁盘的缓存中获取，再次编译时无需再次进行解析 AST。","tags":["webpack"],"categories":["前端工程化"]},{"title":"docker","path":"/2024/01/19/docker/","content":"基本概念Docker 是一个用于 构建、运行、传送 应用程序的平台。 将以下这些打包，以便在任何环境中都可以正确地运行： 配置文件、启动命令 应用程序、环境变量 第三方软件库和依赖包 运行时环境 操作系统（OS） 为什么要使用 Docker 环境一致性： Docker 容器包含应用程序及其依赖项，确保在不同的环境中具有一致的运行结果。这有助于避免”在我的机器上可以运行”这类问题。 轻量级： Docker 容器与虚拟机相比更轻量，因为它们共享主机操作系统的内核。这使得 Docker 容器更快速启动、占用更少资源，并提供更高的性能。 快速部署： Docker 容器可以快速部署，几乎可以在任何支持 Docker 的环境中运行。这加速了应用程序的交付流程，使得新版本的应用程序可以更快地投入生产环境。 易于扩展： Docker 容器可以在分布式环境中轻松扩展，实现负载均衡和高可用性。通过使用 Docker Swarm 或 Kubernetes 等容器编排工具，可以方便地管理多个容器的部署和伸缩。 隔离性： Docker 容器提供了隔离的运行环境，每个容器之间相互隔离，不会相互影响。这使得应用程序更加安全，同时也更容易管理多个服务或应用。 版本控制和回滚： Docker 允许将应用程序和其依赖项打包成镜像，并通过版本控制来管理。这样，可以方便地回滚到之前的版本，降低了部署过程中的风险。 生态系统和社区支持： Docker 拥有庞大的社区，有大量的公开可用的镜像和工具。这使得开发人员可以轻松地获取和分享容器化的应用程序组件，加速了开发和部署过程。 跨平台： Docker 容器可以在各种操作系统上运行，包括 Linux、Windows 和 macOS 等。这种跨平台性使得开发、测试和部署更加灵活。 Docker 和虚拟机的区别Docker 容器和虚拟机（VM）是两种不同的虚拟化技术，它们在实现和性能方面存在一些关键的区别。以下是 Docker 容器和虚拟机之间的主要区别： 架构差异： Docker 容器： Docker 容器共享主机操作系统的内核，但在容器中运行的应用程序有自己独立的用户空间。这使得 Docker 容器相对轻量，启动迅速。 虚拟机： 虚拟机通过使用虚拟化层创建独立的虚拟硬件，每个虚拟机都运行一个完整的操作系统实例。这增加了虚拟机的重量和启动时间。 资源占用： Docker 容器： 由于容器共享主机内核，它们占用的资源更少，启动更快。容器可以在同一主机上运行成百上千个实例而不会显著增加资源开销。 虚拟机： 每个虚拟机都需要独立的操作系统和虚拟硬件，因此它们通常占用更多的资源，并且启动时间较长。 隔离性： Docker 容器： 容器提供了一定程度的隔离，但容器共享主机内核，因此在安全性上相对较弱。 虚拟机： 虚拟机提供更强的隔离，因为它们运行独立的操作系统。虚拟机通常在安全性方面更有优势。 跨平台性： Docker 容器： 容器可以在不同操作系统上运行，前提是它们使用相同的 Docker 引擎。这增加了跨平台的灵活性。 虚拟机： 虚拟机通常依赖于特定的虚拟化技术和操作系统，因此在不同平台之间移植性较差。 镜像大小： Docker 容器： Docker 镜像通常比虚拟机镜像小得多，因为它们只包含应用程序及其依赖项，而不包括整个操作系统。 虚拟机： 虚拟机镜像包含完整的操作系统，因此它们通常较大。 根据应用程序的需求和部署场景，选择使用 Docker 容器还是虚拟机取决于具体情况。一些场景中它们也可以结合使用，例如在虚拟机中运行 Docker 容器。 安装配置 下载 Docker Desktop for Mac：访问 Docker 官方网站下载 Docker Desktop for Mac。安装程序将包含 Docker 引擎以及 Docker CLI 等组件。 安装 Docker Desktop：双击下载的 Docker.dmg 文件，将 Docker 图标拖动到 Applications 文件夹中，然后在 Applications 文件夹中运行 Docker。 运行 Docker Desktop：打开 Docker 应用程序，它将启动 Docker 引擎。 验证 Docker 安装：打开终端（Terminal）并运行以下命令检查 Docker 版本 docker --version 常用命令Docker 提供了丰富的命令行工具，用于管理和操作 Docker 容器、镜像等。以下是一些常用的 Docker 命令： 镜像命令：查看本地镜像列表： docker images从 Docker Hub 下载镜像： docker pull image_name:tag构建镜像： docker build -t image_name:tag .删除本地镜像： docker rmi image_name:tag 容器命令： 启动容器：docker run image_name:tag 启动容器并指定名称：docker run --name container_name image_name:tag 查看运行中的容器：docker ps 查看所有容器（包括停止的）：docker ps -a 停止容器： docker stop container_id/container_name 删除容器：docker rm container_id/container_name 进入运行中的容器：docker exec -it container_id/container_name /bin/bash 日志和信息： 查看容器日志：docker logs container_id/container_name 查看容器详细信息：docker inspect container_id/container_name 网络命令： 查看网络列表：docker network ls 查看网络详细信息：docker network inspect network_name 其他常用命令： 查看 Docker 版本：docker version 查看 Docker 信息：docker info 清理无用资源（镜像、容器等）：docker system prune 查看 Docker 帮助：docker --help 构造镜像、运行容器构建 Docker 镜像是通过定义一个 Dockerfile 文件来描述镜像的构建过程。以下是一个简单的 Dockerfile 示例，演示如何构建一个基于 Node.js 的简单 Web 应用的镜像 # 使用官方Node.js镜像作为基础镜像FROM node:14# 设置工作目录WORKDIR /app# 将应用程序的依赖项文件拷贝到工作目录COPY package*.json ./# 安装应用程序的依赖项RUN npm install# 将应用程序文件拷贝到工作目录COPY . .# 暴露应用程序监听的端口EXPOSE 3000# 定义启动命令CMD [node, app.js] 上述 Dockerfile 的主要步骤包括： 使用官方 Node.js 14 镜像作为基础镜像。设置工作目录为app。将应用程序的 package.json 和 package-lock.json 拷贝到工作目录。运行 npm install 安装应用程序的依赖项。将应用程序文件拷贝到工作目录。暴露应用程序监听的端口（这里是 3000）。定义启动容器时运行的命令。 接下来，可以使用以下命令在 Dockerfile所在的目录中构建镜像： docker build -t your_image_name:tag .其中，your_image_name 是你为镜像定义的名称，tag 是版本标签。最后的点.表示 Dockerfile 所在的当前目录。 构建完成后，你可以使用以下命令查看构建的镜像docker images 然后，你可以使用构建的镜像来运行容器：docker run -p 3000:3000 -d your_image_name:tag Docker Compose特点和用途:Docker Compose 是 Docker 官方提供的工具，用于定义和运行多容器的 Docker 应用。使用 YAML 文件定义多容器应用的服务、网络和卷等配置。主要用于开发和测试环境，以便在本地一次性启动多个相关联的容器。简化了通过 docker-compose up 一键启动整个应用程序的过程。 基本概念: services: 定义应用中的各个服务，每个服务对应一个容器。 networks: 定义服务之间的网络连接。 volumes: 定义服务使用的数据卷。 示例 docker-compose.yml 文件version: 3services: web: image: nginx ports: - 8080:80 app: image: your_app_image ports: - 5000:5000","tags":["docker"]},{"title":"宏任务和微任务","path":"/2024/01/16/macro-micro-Task/","content":"一个很好的练习事件循环的网站 https://www.jsv9000.app/ JS 将 异步任务 分为宏任务和微任务 1. 同步代码（js 执行栈回调栈）2. 微任务的异步代码（js 引擎） Process.nextTick(node) Promise.then() catch() Promise 本身同步，then 和 catch 的回调函数是异步的微任务 AsyncAwait Object.observe 等等 3. 宏任务的异步代码（宿主环境-浏览器、Node） script(代码块) AjaxFetch setTimeoutsetInterval setImmediate 同步代码-微任务-宏任务例子例子 1console.log(1);setTimeout(function () console.log(2); //macro, 0);const p = new Promise((resolve, reject) = console.log(3); resolve(1000); console.log(4););p.then((data) = console.log(data); //micro);console.log(5); 打印结果：1 3 4 5 1000 2 例子 2new Promise((resolve, reject) = resolve(1); new Promise((resolve, reject) = resolve(2); ).then((data) = console.log(data); );).then((data) = console.log(data););console.log(3); 打印结果： 3 2 1 例子 3console.log(11);setTimeout(() = console.log(12); let p = new Promise((resolve) = resolve(13); ); p.then((res) = console.log(res); ); console.log(15);, 0);console.log(14); 打印结果： 11 14 12 15 13 例子 4setTimeout(() = console.log(1);, 0);new Promise((resolve) = console.log(2); resolve(p1); new Promise((resolve) = console.log(3); setTimeout(() = resolve(setTimeout2); console.log(4); , 0); resolve(p2); ).then((data) = console.log(data); ); setTimeout(() = resolve(setTimeout1); console.log(5); , 0);).then((data) = console.log(data););console.log(6); 打印结果：2 3 6 p2 p1 1 4 5 例子 5async function async1() console.log(async1 start); await async2(); console.log(async1 end);async function async2() console.log(async2);console.log(script start);setTimeout(() = console.log(setTimeout);, 0);async1(); await async2();后面的代码的代码属于微任务 打印结果： script start 、 async1 start 、 async2 、async1 end 、setTimeout","tags":["JS"]},{"title":"nginx","path":"/2024/01/16/nginx/","content":"简介Nginx（发音为”engine-x”）是一个高性能的开源 Web 服务器和反向代理服务器。以下是 Nginx 的一些关键特点和简介： 高性能： Nginx 以高性能而著称，能够处理大量并发连接，同时占用较少的系统资源。它的事件驱动架构和非阻塞 IO 模型有助于实现高效的性能。 轻量级和可扩展： Nginx 的设计目标之一是保持简单、轻量级且可扩展。它的模块化架构使得用户可以根据需要选择性地添加功能模块。 反向代理： Nginx 可以用作反向代理服务器，接收客户端请求并将其转发到后端服务器。这使得它成为负载均衡和提高 Web 应用性能的理想选择。 负载均衡： Nginx 支持基于轮询、IP 哈希等算法的负载均衡，能够平均分配流量到多个后端服务器，提高系统的可用性和稳定性。 静态文件服务： Nginx 非常擅长提供静态文件服务，可以快速地传送静态内容，减轻后端服务器的负担。 SSLTLS 支持： Nginx 支持 SSLTLS 协议，能够提供安全的加密通信，用于保护网站和应用程序的数据传输。 虚拟主机： Nginx 支持虚拟主机配置，允许多个域名共享同一台服务器，并根据域名或其他条件进行不同的配置。 日志记录： Nginx 提供详细的访问日志和错误日志，有助于进行故障排除和性能优化。 社区支持和活跃： Nginx 是一个开源项目，拥有庞大的用户社区，有许多第三方模块和插件可用。它也有商业版本（NGINX Plus）提供额外的功能和支持。 总体而言，Nginx 是一个强大、灵活且高性能的 Web 服务器，适用于处理各种 Web 应用程序和场景。由于其卓越的性能和可扩展性，它被广泛用于互联网和企业环境中 安装1. 包管理安装brew install nginx or sudo apt updatesudo apt install nginx 2. 编译安装下载源码，预编译，编译，安装，比较灵活，可以自定义配置一些东西，但比较麻烦 3. 使用 Docker 安装docker pull nginx 启动服务 启动命令： nginx 没有消息就是好消息 打开浏览器输入 localhost,能打开页面看到 Welcome to nginx! ,说明启动成功 ps -ef|grep nginx可查看 nginx 进程 nginx -s signalquit : 优雅停止stop: 立即停止reload：重新配置文件reopen：重新打开日志文件 nginx -V可以查看 Nginx 的安装目录，编译参数等等 如何查看 nginx 运行的网页的位置 nginx -V 找到–prefix，例如： –prefixopthomebrewCellarnginx1.21.6_1 cd /opt/homebrew/Cellar/nginx/1.21.6_1 ls -ltr 可以看到列表中有 html cd html ls -ltr code index.html 搭建一个属于自己的个人博客网站 新建博客 npm install hexo-cli -ghexo init blogcd blog;npm installhexo server/ hexo s 部署到 nginx 上然后将 hexo 生成的网页文件(在 public 目录下)，复制到 nginx 中 cp -rf * /opt/homebrew/var/www nginx 配置1. 基本的服务器配置server listen 80; # 监听端口 server_name example.com www.example.com; # 域名配置 root /path/to/your/webroot; # 网站根目录 index index.html index.htm; # 默认首页 location / # 其他配置 2. 反向代理配置server listen 80; server_name example.com; location / proxy_pass http://backend_server; # 后端服务器地址 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; # 其他反向代理配置 3. 负载均衡配置upstream backend server backend1.example.com; server backend2.example.com; # 添加更多后端服务器server listen 80; server_name example.com; location / proxy_pass http://backend; # 其他负载均衡配置 4. SSLTLS 配置server listen 443 ssl; server_name secure.example.com; ssl_certificate /path/to/ssl_certificate.crt; ssl_certificate_key /path/to/ssl_certificate.key; # 其他SSL/TLS配置 5. 重定向配置server listen 80; server_name www.example.com; return 301 http://example.com$request_uri; # 重定向到非www域名 反向代理和负载均衡正向代理和反向代理正向代理 代理客户端（client）（VPN）反向代理 代理服务端（server） （比如我们通过 Google 搜索内容，我们只通过一个域名访问，但其实转发到了后面很多个不同的服务器端上，从而隐藏了真实的服务器 IP 地址、端口等信息） 例子 首先先用 go 生成一个简单的 web 页面，在端口 8000 监听，这里我是用 chatGPT 自动帮我生成： 如果没有安装 go,请先安装，我这边直接用brew install go package mainimport (\tfmt\tnet/http)func main() // 设置路由\thttp.HandleFunc(/, func(w http.ResponseWriter, r *http.Request) fmt.Fprintf(w, Hello, World!)\t)\t// 启动服务器并监听8000端口\tport := 8000\tfmt.Printf(服务器正在监听端口 %d... , port)\terr := http.ListenAndServe(fmt.Sprintf(:%d, port), nil)\tif err != nil fmt.Println(启动服务器时发生错误:, err) 我们将上面的文件再复制出两个文件，分别改写端口号为 8001、8002，分别运行在浏览器中。 然后我们再修改一下 nginx 的配置文件code /opt/homebrew/etc/nginx/nginx.conf添加upstream的配置，这个就是反向代理的配置 upstream backend server 127.0.0.1:8000; server 127.0.0.1:8001; server 127.0.0.1:8002; 在 下面的 server 配置中再添加一个 location 的配置，访问 app 都将代理到刚刚的配置中 location /app proxy_pass http://backend; 重新 reload 一下 nginx 配置nginx -s reload https 配置http + ssl 证书 - httpshttp 默认端口： 80https 默认端口： 443在主流的云平台（腾讯云，阿里云，AWS，GCP）上都可以申请免费的 ssl 证书，证书申请完后会得到证书文件(cacert.pem)和私钥文件（private.key），如果没有云平台也没有关系，我们可以通过 openssl 来自己生成一个自签名的证书 openssl 生成证书 生成私钥文件（private key）openssl genrsa -out private.key 2048 根据私钥生成证书签名请求文件openssl req -new -key private.key -out cert.csr 使用私钥对证书申请进行签名从而生成证书（pem 文件）openssl x509 -req -in cert.csr -out cacert.pem -signkey private.key nginx 配置这两个文件需要放置到服务器上证书文件(cacert.pem)和私钥文件（private.key）,然后在 nginx 的配置文件中进行配置 在监听后加上 ssl listen 443 ssl; 将证书和私钥填写进入 ssl_certificate /opt/homebrew/etc/nginx/cacert.pemssl_certificate_key /opt/homebrew/etc/nginx/private.key 然后再加上一些验证配置和加密协议，这些配置基本是固定的 server listen 443 ssl; server_name your_domain.com; ssl_certificate /etc/nginx/ssl/your_domain.crt; ssl_certificate_key /etc/nginx/ssl/your_domain.key; # 可选：配置 SSL 优化和安全性 ssl_protocols TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers off; ssl_ciphers TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384; # 其他 SSL 配置... location / # 配置其他相关的代理或静态文件服务... 我们的证书是自签名的，没有经过 ca 认证，所以打开网站会提示不安全 配置 http 重定向到 httpsserver {listen 80;server_name your_domain.com www.your_domain.com; # 重定向到 HTTPS return 301 https://$host$request_uri; } 虚拟主机虚拟主机可以在一个服务器上部署多个站点 配置nginx 中通过server块来配置虚拟主机，每个server块就是一个虚拟主机 server listen 80; # 监听端口 server_name your_domain.com www.your_domain.com; # 替换为你的域名 root /path/to/your/webroot; # 替换为你的网站根目录 index index.html index.htm; # 默认首页 location / # 配置其他参数，比如代理、缓存等 # 配置其他特定的location块，如果需要的话 如何将一个 vue 项目部署到服务器上 创建一个 vue 项目，并打包好 open nginx 配置项目 cd /opt/homebrew/etc/nginx code . 新建一个 servers 文件夹，在 servers 里建vue.conf server listen 5173; server_name localhost;//替换成域名 location / root /Users/mei/vue-demo/dist;//打包项目地址 index index.html index.htm; nginx -s reload在浏览器中输入 localhost:5173 就可以看到 vue 项目。","tags":["nginx"]},{"title":"BFF(Backend For Frontend)","path":"/2024/01/16/BFF/","content":"BFF，既 Backend For Frontend。 中文翻译过来的意思是前端的后端。 介绍前端后端 (BFF) 是一种架构模式，涉及为每个客户端应用程序创建单独的后端。这可以更好地分离关注点，因为可以根据客户端应用程序的需求专门定制后端。BFF 还可以通过减少客户端和服务器之间需要传输的数据量来提高性能和可扩展性。 比喻前端后端（BFF）架构可以类比为一套量身定制的套装。正如西装是根据穿着者的具体尺寸和偏好量身定制的一样，BFF 也是根据客户端应用程序的特定需求和要求量身定制的。这可以更好地分离关注点并提高性能，类似于合身的西装如何增强穿着者的舒适度和外观。 为什么前端需要学习 Node.js?前端工程师学习 Node.js 的必要性，也在此体现得淋漓尽致。Node.js 是实现 BFF 层的首选技术，因为它允许前端工程师使用熟悉的 JavaScriptTvpeScript 来构建这一服务层。除此之外，现代前端开发的方方面面都离不开 Node.js:服务端渲染(SSR)框架(如 Next.js,Nuxt.js)均基于 Node.js 运行。前端工程化的生态系统(Webpack, Vite,Babel,ESLint)完全构建在 Node.js 之上。掌握 Node.js 是前端工程师迈向全栈开发，具备独立交付项目能力的关键一步。 何时使用 BFF 模式？ 微服务架构 BFF 在微服务架构中特别有用，其中每个微服务都可以有自己的 BFF。这使得微服务之间具有更大的灵活性和独立性，因为每个微服务都可以为其特定的客户端应用程序拥有自己定制的后端。 架构解耦与其他架构模式（例如微前端）结合使用，它创建了一个更具凝聚力和模块化的系统 跨平台开发当构建多个客户端应用程序时，需要不同的后端来保持更好的关注点分离。 敏捷开发BFF 还可以在不影响后端的情况下更轻松地维护和更新客户端应用程序，从而帮助简化开发过程。 性能优势使用 BFF 可以通过减少客户端和服务器之间传输的数据量来提高性能和可扩展性 构建微前端在构建微前端时，将前端分解为更小、更易于管理的部分，以便可以独立开发和部署。每个微前端都可以有自己的 BFF，这可以提高关注点分离和灵活性 何时不使用 BFF 模式？1.小团队BFF 可能会带来额外的复杂性和维护开销，因为每个客户端应用程序都有自己的后端需要维护。对于资源有限的小型团队和初创公司来说，这尤其具有挑战性。 2. 产品可行性当构建不需要复杂客户端应用程序的产品时，不需要根据特定客户端应用程序的需求定制后端 3.Rest 足够了在构建需要传统 RESTful API 架构（这是 Web API 最常见的架构）的应用程序时。 4. 编排延迟在构建需要直接客户端到微服务通信的应用程序时，这样做是为了减少解耦微服务之间的附加通信层带来的延迟。 代码示例以下是使用 React.js 的 BFF（前端后端）代码示例 import React, useState, useEffect from react;const App = () = const [data, setData] = useState([]); useEffect(() = fetch(/api) .then((response) = response.json()) .then((data) = setData(data)); , []); return ( div data.map((item) = ( div key=item.id h2item.title/h2 pitem.body/p /div )) /div );; 此代码设置一个 React 组件，该组件从 BFF API 端点获取数据并将其呈现在页面上。useEffect 挂钩用于在组件安装后立即获取数据。使用 useState 挂钩将获取的数据存储在组件的状态中，然后进行映射以显示数据数组中的每个项目。 BFF 模式的替代方案BFF 并不是唯一支持复杂 Web 开发的架构模式。还有其他流行的模式可以独立使用或与 BFF 一起使用： API 网关模式在此模式中，单个 API 网关负责处理所有客户端请求并与适当的微服务和后端进行通信。这可以简化架构并减少维护开销，因为客户端和后端之间只有一个接触点。但是，在处理 API 网关和微服务后端之间的路由和通信时，它也可能会带来额外的延迟和复杂性。 无服务器架构该架构基于按需运行代码的概念，而不是始终运行专用服务器或服务器集群。这有助于降低成本并简化架构。 GraphQLGraphQL 是 RESTful API 的替代方案，允许客户端指定他们需要的确切数据并仅接收该数据。这可以减少客户端和服务器之间传输的数据量并提高性能。 GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools. 微前端这种架构模式涉及将前端分解为更小、更易于管理的部分，这些部分可以独立开发和部署。每个微前端都可以有自己的 BFF，这可以提高关注点分离和灵活性。 服务网格架构在此架构中，添加了专用基础设施层来处理服务到服务的通信。这可以简化架构并降低处理服务之间通信的复杂性。 API 成分这涉及将多个 API 聚合到单个 API 中，这可以简化架构并减少检索数据所需的请求数量。 客户端到微服务的直接通信在此架构中，客户端直接与微服务通信，而不是通过 BFF 或 API 网关。这可以减少额外通信层带来的复杂性和延迟。然而，这也会降低灵活性和关注点分离。事件驱动架构这种架构涉及使用事件来触发系统中的操作，这可以提高可扩展性和模块化性。 SOA（面向服务的架构）这涉及将系统分解为可以独立开发和部署的单独服务。每个服务都可以有自己的 BFF 或 API 网关。这可以提高可扩展性和灵活性。 传统 RESTful API这是 Web API 最常见的架构，客户端通过 RESTful API 与服务器进行通信。 引用BFF Pattern: The Good, the Bad, and the Alternatives. - LinkedIn","tags":["BFF"]},{"title":"React 中的合成事件","path":"/2024/01/11/React-SyntheticEvent/","content":"React 中的合成事件（SyntheticEvent）是一种封装了原生浏览器事件的虚拟事件对象。React 通过合成事件来处理浏览器事件，而不直接使用原生的事件对象。这样做的原因有以下几点： import React from react;class MyComponent extends React.Component handleClick = (event) = // 阻止事件的默认行为 event.preventDefault(); // 输出事件对象 console.log(Clicked!, event); ; render() return button onClick=this.handleClickClick me/button; export default MyComponent; 在这个示例中，我们定义了一个 MyComponent 组件，并在组件中定义了一个点击事件处理函数 handleClick。在 render 方法中，我们将 handleClick 函数绑定到了按钮的 onClick 事件上。当按钮被点击时，React 会自动创建一个合成事件对象，并将它传递给 handleClick 函数。在 handleClick 函数中，我们可以像使用原生事件对象一样使用合成事件对象，例如阻止默认行为、获取事件目标等。 跨浏览器兼容性：React 的合成事件是跨浏览器兼容的，它会自动处理不同浏览器之间的差异，使得开发者无需关心不同浏览器的兼容性问题。 性能优化：React 的合成事件采用了事件委托机制，将事件处理逻辑集中在顶层容器上，而不是将事件处理函数直接绑定到每个 DOM 元素上。这样可以减少内存占用和事件绑定数量，提高页面性能。 事件池：React 的合成事件采用了事件池（Event Pool）机制，重用了事件对象，减少了对象创建和销毁的开销。当事件处理函数执行完毕后，事件对象会被重置并放回到事件池中，以供下次使用。 事件系统扩展：React 的合成事件系统提供了丰富的 API 和功能，可以方便地进行事件的捕获、冒泡、阻止默认行为、停止事件传播等操作，同时还支持事件委托和事件代理等高级特性。 综上所述，React 使用合成事件来统一处理浏览器事件，提供了跨浏览器兼容性、性能优化和丰富的事件处理功能，使得开发者可以更轻松地编写可维护、高性能的 React 应用。","tags":["React"]},{"title":"react","path":"/2024/01/02/react/","content":"组件初始化—-render 方法—-生成虚拟 DOM—ReactDOM.render 方法—真实 DOM 组件更新—- render 方法—-生成新的虚拟 DOM—-diff 算法—-定位出两次虚拟 DOM 的差异","tags":["React"]},{"title":"NodeJs-Express","path":"/2023/12/27/NodeJs-Express/","content":"简单的 demo const express = require(express);//HTTP请求体解析中间件const bodyParser = require(body-parser);//日志组件const morgan = require(morgan);let jsonParser = bodyParser.json( extended: false );const app = express();const unknownEndpoint = (request, response) = response.status(404).send( error: unknown endpoint );;app.use(unknownEndpoint);app.use(express.json());morgan.token(body, function (req, res) return JSON.stringify(req.body););morgan.format( format, :method :url :status :res[content-length] - :response-time ms :body);app.use(morgan(format));let persons = [ id: 1, name: Arto Hellas, number: 040-123456, , id: 2, name: Ada Lovelace, number: 39-44-5323523, , id: 3, name: Dan Abramov, number: 12-43-234345, , id: 4, name: Mary Poppendieck, number: 39-23-6423122, ,];app.get(/api/persons, (request, response) = response.json(persons););app.get(/info, (request, response) = const peopleNum = persons.length; response.send( `pPhonebook has info for $peopleNum people/pp$new Date()/p` ););app.get(/api/persons/:id, (request, response) = const id = Number(request.params.id); const person = persons.find((i) = i.id === id); if (person) response.json(person); else response.status(404).end(); );app.delete(/api/persons/:id, (request, response) = const id = Number(request.params.id); persons = persons.filter((i) = i.id !== id); response.status(204).send( msg: delete successful ).end(););app.post(/api/persons, jsonParser, (request, response) = const person = request.body; if (!person.name) response.status(400).send( error: please provide name ); return; if (!person.number) response.status(400).send( error: please provide number ); return; const isExistName = persons.find((i) = i.name === person.name); if (isExistName) response.status(400).send( error: name must be unique ); return; person.id = Math.round(Math.random() * (1000 - 100000000)) + 100000000; persons = persons.concat(person); response.json(person););app.listen(3001); 中间件 （Middleware）中间件是可以用来处理 request 和 response 对象的函数。 我们之前使用的 json-parser 从请求中获取原始数据，这些数据存储在 request 对象中，将其解析为一个 JavaScript 对象，并将其作为一个新的属性 body 分配给 request 对象。 让我们来实现我们自己的中间件，它可以打印出发送到服务器的每个请求的信息。 中间件是一个接收三个参数的函数 const requestLogger = (request, response, next) = console.log(Method:, request.method); console.log(Path: , request.path); console.log(Body: , request.body); console.log(---); next();; 在函数体的最后，调用作为参数传递的 next 函数。这个next 函数将控制权交给下一个中间件。 中间件是这样被使用的。 app.use(requestLogger) 中间件函数的调用顺序是它们被 Express 服务器对象的 use 方法所使用的顺序。请注意，json-parser 是在 requestLogger 中间件之前被使用的，因为否则在执行记录器的时候，request.body 将不会被初始化。 如果我们想让中间件函数在路由事件处理程序被调用前执行，那么就必须在路由之前使用这些中间件函数。也有一些情况，我们想在路由之后定义中间件函数。在实践中，这意味着我们要定义的中间件函数只有在没有路由处理 HTTP 请求时才会被调用。 让我们在路由之后添加以下中间件，用于捕捉向不存在的路由发出的请求。对于这些请求，中间件将返回一个 JSON 格式的错误信息。 const unknownEndpoint = (request, response) = response.status(404).send( error: unknown endpoint )app.use(unknownEndpoint) morgangithub 注意，即使在控制台中记录数据也是危险的，因为它可能包含敏感数据，并可能违反当地的隐私法（如欧盟的 GDPR）或商业标准。 自定义日志格式morgan.format( format, :method :url :status :res[content-length] - :response-time ms :body); 自定义 tokenmorgan.token(body, function (req, res) return JSON.stringify(req.body);); 控制台运行结果POST /api/persons 400 31 - 0.621 ms name:aapls,number:0asd20-8780 mongoose 在 https://cloud.mongodb.com/ 上建好 project 后，本地连接上（这个步骤不记得的可以上网搜索） 安装 mongoose npm install mongoose","tags":["node","express"]},{"title":"vue中的nextTick","path":"/2023/12/26/vue-nextTick/","content":"在 Vue.js 中， nextTick方法用于在 DOM 更新之后执行回调函数。它的使用方式是调用 this.$nextTick()，并传入一个回调函数作为参数。回调函数将在 DOM 更新之后被执行，这样可以确保在修改数据之后立即操作 DOM。 import createApp, nextTick from vue;const app = createApp( setup() const message = ref(Hello!); const changeMessage = async (newMessage) = message.value = newMessage; // 这里获取DOM的value是旧值 await nextTick(); // nextTick 后获取DOM的value是更新后的值 console.log(Now DOM is updated); ; ,); nextTick 方法的原理是利用 JavaScript 的事件循环机制。当你修改了 Vue 实例的数据后，Vue 引擎会在下一个事件循环周期中异步地执行 DOM 更新。而 nextTick 方法正是在当前的事件循环周期结束时注册一个微任务，确保其回调函数在下一个 DOM 更新之后执行。 具体来说，nextTick 方法会利用浏览器提供的 Promise、MutationObserver 或 setImmediate（如果可用）等异步任务调度机制，在下一个微任务或宏任务中执行注册的回调函数。这样可以确保回调函数在 DOM 更新之后被调用，从而避免了在修改数据之后立即操作 DOM 可能导致的问题。 为什么要 nextTick一个例子让大家明白，如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新，有了 nextTick 机制，只需要更新一次，所以为什么有 nextTick 存在，相信大家心里已经有答案了。 numfor(let i=0; i100000; i++)\tnum = i 总结nextTick 是 vue 中的更新策略，也是性能优化手段，基于 JS 执行机制实现 vue 中我们改变数据时不会立即触发视图，如果需要实时获取到最新的 DOM，这个时候可以手动调用 nextTick","tags":["vue"]},{"title":"前端文件流、切片下载和上传","path":"/2023/12/22/upload-big-file/","content":"一、前端文件流操作下面创建一个 fileUpload 的函数式组件，当用户选择文件时，通过FileReader将文件内容读取为 ArrayButter,然后将ArrayBuffer转换为十六进制字符串，并将结果显示在页面上。 import React, useState from react;function FileInput() const [fileContent, setFileContent] = useState(); // 读取文件内容到ArrayBuffer function readFileToArrayBuffer(file) return new Promise((resolve, reject) = const reader = new FileReader(); // 注册文件读取完成后的回调函数 reader.onload = function (event) const arrayBuffer = event.target.result; resolve(arrayBuffer); ; // 读取文件内容到ArrayBuffer reader.readAsArrayBuffer(file); ); // 将ArrayBuffer转为十六进制字符串 function arrayBufferToHexString(arrayBuffer) const uint8Array = new Uint8Array(arrayBuffer); let hexString = ; for (let i = 0; i uint8Array.length; i++) const hex = uint8Array[i].toString(16).padStart(2, 0); hexString += hex; return hexString; // 处理文件选择事件 function handleFileChange(event) const file = event.target.files[0]; // 获取选中的文件 if (file) readFileToArrayBuffer(file) .then((arrayBuffer) = const hexString = arrayBufferToHexString(arrayBuffer); setFileContent(hexString); ) .catch((error) = console.error(文件读取失败:, error); ); else setFileContent(请选择一个文件); return ( div input type=file onChange=handleFileChange / div h4文件内容：/h4 prefileContent/pre /div /div );export default FileInput; 二、文件切片下载文件切片下载的好处： 快速启动：客户端可以快速开始下载，因为只需要下载第一个切片即可。 并发下载：通过使用多个并发请求下载切片，可以充分利用带宽，并提高整体下载速度。 断点续传：如果下载中断，客户端只需要重新下载中断的切片，而不需要重新下载整个文件。 const [selectedFile, setSelectedFile] = useState(null);const [progress, setProgress] = useState(0);// 处理文件选择事件function handleFileChange(event) setSelectedFile(event.target.files[0]);// 处理文件上传事件function handleFileUpload() if (selectedFile) // 计算切片数量和每个切片的大小 const fileSize = selectedFile.size; const chunkSize = 1024 * 1024; // 设置切片大小为1MB const totalChunks = Math.ceil(fileSize / chunkSize); // 创建FormData对象，并添加文件信息 const formData = new FormData(); formData.append(file, selectedFile); formData.append(totalChunks, totalChunks); // 循环上传切片 for (let chunkNumber = 0; chunkNumber totalChunks; chunkNumber++) const start = chunkNumber * chunkSize; const end = Math.min(start + chunkSize, fileSize); const chunk = selectedFile.slice(start, end); formData.append(`chunk-$chunkNumber`, chunk, selectedFile.name); // 发起文件上传请求 axios .post(/upload, formData, onUploadProgress: (progressEvent) = const progress = Math.round( (progressEvent.loaded / progressEvent.total) * 100 ); setProgress(progress); , ) .then((response) = console.log(文件上传成功:, response.data); ) .catch((error) = console.error(文件上传失败:, error); ); 当用户选择文件后，通过 handleFileChange 函数处理文件选择事件，将选择的文件保存在 selectedFile 状态中。当用户点击上传按钮时，通过 handleFileUpload 函数处理文件上传事件。在 handleFileUpload 函数中，计算切片数量和每个切片的大小，并创建一个 FormData 对象用于存储文件信息和切片数据。 实现客户端切片下载的方案实现客户端切片下载的基本方案如下： 服务器端将大文件切割成多个切片，并为每个切片生成唯一的标识符。 客户端发送请求获取切片列表，同时开始下载第一个切片。 客户端在下载过程中，根据切片列表发起并发请求下载其他切片，并逐渐拼接合并下载的数据。 当所有切片都下载完成后，客户端将下载的数据合并为完整的文件 function downloadFile() // 发起文件下载请求 fetch(/download, method: GET, headers: Content-Type: application/json, , ) .then((response) = response.json()) .then((data) = const totalSize = data.totalSize; const totalChunks = data.totalChunks; let downloadedChunks = 0; let chunks = []; // 下载每个切片 for (let chunkNumber = 0; chunkNumber totalChunks; chunkNumber++) fetch(`/download/$chunkNumber`, method: GET, ) .then((response) = response.blob()) .then((chunk) = downloadedChunks++; chunks.push(chunk); // 当所有切片都下载完成时 if (downloadedChunks === totalChunks) // 合并切片 const mergedBlob = new Blob(chunks); // 创建对象 URL，生成下载链接 const downloadUrl = window.URL.createObjectURL(mergedBlob); // 创建 a 元素并设置属性 const link = document.createElement(a); link.href = downloadUrl; link.setAttribute(download, file.txt); // 模拟点击下载 link.click(); // 释放资源 window.URL.revokeObjectURL(downloadUrl); ); ) .catch((error) = console.error(文件下载失败:, error); ); 我们看下代码，首先使用 BLOB 对象创建一共对象 URL，用于生成下载连接，然后创建 a 标签并且设置 href 的属性为刚刚创建的对象 URL,继续设置 a 标签的 download 属性是文件名，方便点击的时候自动下载文件。 显示下载进度和完成状态为了显示下载进度和完成状态，可以在客户端实现以下功能： 显示进度条：客户端可以通过监听每个切片的下载进度来计算整体下载进度，并实时更新进度条的显示。 显示完成状态：当所有切片都下载完成后，客户端可以显示下载完成的状态，例如显示一个完成的图标或者文本。这里我们可以继续接着切片上传代码示例里的继续写。 function handleFileDownload() axios.get(/download, responseType: blob, onDownloadProgress: progressEvent = const progress = Math.round((progressEvent.loaded / progressEvent.total) * 100); setProgress(progress); ) .then(response = // 创建一个临时的URL对象用于下载 const url = window.URL.createObjectURL(new Blob([response.data])); const link = document.createElement(a); link.href = url; link.setAttribute(download, file.txt); document.body.appendChild(link); link.click(); document.body.removeChild(link); ) .catch(error = console.error(文件下载失败:, error); );button onClick=handleFileDownload下载文件/buttondiv进度：progress%/div 当用户点击下载按钮时，通过 handleFileDownload 函数处理文件下载事件。 在 handleFileDownload 函数中，使用 axios 库发起文件下载请求，并设置 responseType: blob 表示返回二进制数据。 通过监听 onDownloadProgress 属性获取下载进度，并更新进度条的显示。 下载完成后，创建一个临时的 URL 对象用于下载，并通过动态创建 a 元素模拟点击下载。 实现断点续传的技术：记录和恢复上传状态 在前端，可以使用 localStorage 或 sessionStorage 来存储已上传的切片信息，包括已上传的切片索引、切片大小等。 每次上传前，先检查本地存储中是否存在已上传的切片信息，若存在，则从断点处继续上传。 在后端，可以使用一个临时文件夹或数据库来记录已接收到的切片信息，包括已上传的切片索引、切片大小等。 在上传完成前，保存上传状态，以便在上传中断后能够恢复上传进度。 在实现大文件上传时要考虑服务器端的处理能力和存储空间，以及安全性问题。同时，为了保障断点续传的准确性，应该尽量避免并发上传相同文件的情况，可以采用文件唯一标识符或用户会话标识符进行区分。","tags":["JS","性能优化"],"categories":["性能优化"]},{"title":"软链接和硬链接","path":"/2023/12/19/hard-symbol-link/","content":"假设我们有一个文件，称为 hello 通过 ln -s 创建一个软链接，通过 ln 可以创建一个硬链接。 $ ln -s hello hello-soft$ ln hello hello-hard$ ls -lhtotal 76845459612 -rw-r--r-- 2 xiange staff 153K 11 19 17:56 hello45459612 -rw-r--r-- 2 xiange staff 153K 11 19 17:56 hello-hard45463415 lrwxr-xr-x 1 xiange staff 5B 11 19 19:40 hello-soft - hello 他们的区别有以下几点: 软链接可理解为指向源文件的指针，它是单独的一个文件，仅仅只有几个字节，它拥有独立的 inode 硬链接与源文件同时指向一个物理地址，它与源文件共享存储数据，它俩拥有相同的 inode","tags":["linux"]},{"title":"indexedDB","path":"/2023/12/19/indexedDB/","content":"一、概述随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。 现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过 4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。 通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。 IndexedDB 具有以下特点。 （1）键值对储存。 IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。 （2）异步。 IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。 （3）支持事务。 IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。 （4）同源限制。 IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。 （5）储存空间大。 IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。 （6）支持二进制储存。 IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。 二、基本概念IndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。 数据库：IDBDatabase 对象 对象仓库：IDBObjectStore 对象 索引： IDBIndex 对象 事务： IDBTransaction 对象 操作请求：IDBRequest 对象 指针： IDBCursor 对象 主键集合：IDBKeyRange 对象 下面是一些主要的概念。 （1）数据库 数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。 IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。 （2）对象仓库 每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。 （3）数据记录 对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。 id: 1, text: foo 上面的对象中，id 属性可以当作主键。 数据体可以是任意数据类型，不限于对象。 （4）索引 为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。 （5）事务 数据记录的读写和删改，都要通过事务完成。事务对象提供error、abort和complete三个事件，用来监听操作结果。 三、操作流程IndexedDB 数据库的各种操作，一般是按照下面的流程进行的。这个部分只给出简单的代码示例，用于快速上手，详细的各个对象的 API 请看这里。 3.1 打开数据库使用 IndexedDB 的第一步是打开数据库，使用indexedDB.open()方法。 var request = window.indexedDB.open(databaseName, version); 这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为 1。 indexedDB.open()方法返回一个 IDBRequest 对象。这个对象通过三种事件error、success、upgradeneeded，处理打开数据库的操作结果。 1）error 事件error 事件表示打开数据库失败。 request.onerror = function (event) console.log(数据库打开报错);; 2）success 事件success 事件表示打开数据库成功。 var db;request.onsuccess = function (event) db = request.result; console.log(数据库打开成功);; 这时，通过 request 对象的 result 属性拿到数据库对象。 3）upgradeneeded 事件如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件 upgradeneeded。 var db;request.onupgradeneeded = function (event) db = event.target.result;; 这时通过事件对象的 target.result 属性，拿到数据库实例。 3.2 新建数据库新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在 upgradeneeded 事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。 通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。 request.onupgradeneeded = function (event) db = event.target.result; var objectStore = db.createObjectStore(person, keyPath: id );; 上面代码中，数据库新建成功以后，新增一张叫做 person 的表格，主键是 id。 更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。 request.onupgradeneeded = function (event) db = event.target.result; var objectStore; if (!db.objectStoreNames.contains(person)) objectStore = db.createObjectStore(person, keyPath: id ); ; 主键（key）是默认建立索引的属性。比如，数据记录是 id: 1, name: 张三 ，那么 id 属性可以作为主键。主键也可以指定为下一层对象的属性，比如 foo: bar: baz 的 foo.bar 也可以指定为主键。 如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。 var objectStore = db.createObjectStore(person, autoIncrement: true ); 上面代码中，指定主键为一个递增的整数。 新建对象仓库以后，下一步可以新建索引。 request.onupgradeneeded = function (event) db = event.target.result; var objectStore = db.createObjectStore(person, keyPath: id ); objectStore.createIndex(name, name, unique: false ); objectStore.createIndex(email, email, unique: true );; 上面代码中，IDBObject.createIndex()的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。 3.3 新增数据新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。 function add() var request = db .transaction([person], readwrite) .objectStore(person) .add( id: 1, name: 张三, age: 24, email: zhangsan@example.com ); request.onsuccess = function (event) console.log(数据写入成功); ; request.onerror = function (event) console.log(数据写入失败); ;add(); 上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（”只读”或”读写”）。新建事务以后，通过IDBTransaction.objectStore(name)方法，拿到 IDBObjectStore 对象，再通过表格对象的 add()方法，向表格写入一条记录。 写入操作是一个异步操作，通过监听连接对象的success事件和error事件，了解是否写入成功。 3.4 读取数据读取数据也是通过事务完成。 function read() var transaction = db.transaction([person]); var objectStore = transaction.objectStore(person); var request = objectStore.get(1); request.onerror = function (event) console.log(事务失败); ; request.onsuccess = function (event) if (request.result) console.log(Name: + request.result.name); console.log(Age: + request.result.age); console.log(Email: + request.result.email); else console.log(未获得数据记录); ;read(); 上面代码中，objectStore.get()方法用于读取数据，参数是主键的值。 3.5遍历数据遍历数据表格的所有记录，要使用指针对象 IDBCursor。 function readAll() var objectStore = db.transaction(person).objectStore(person); objectStore.openCursor().onsuccess = function (event) var cursor = event.target.result; if (cursor) console.log(Id: + cursor.key); console.log(Name: + cursor.value.name); console.log(Age: + cursor.value.age); console.log(Email: + cursor.value.email); cursor.continue(); else console.log(没有更多数据了！); ;readAll(); 上面代码中，新建指针对象的openCursor()方法是一个异步操作，所以要监听success事件。 3.6 更新数据更新数据要使用IDBObject.put()方法。 function update() var request = db .transaction([person], readwrite) .objectStore(person) .put( id: 1, name: 李四, age: 35, email: lisi@example.com ); request.onsuccess = function (event) console.log(数据更新成功); ; request.onerror = function (event) console.log(数据更新失败); ;update(); 上面代码中，put()方法自动更新了主键为 1 的记录。 3.7 删除数据IDBObjectStore.delete()方法用于删除记录。 function remove() var request = db .transaction([person], readwrite) .objectStore(person) .delete(1); request.onsuccess = function (event) console.log(数据删除成功); ;remove(); 3.8 使用索引索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。 假定新建表格的时候，对 name字段建立了索引。 objectStore.createIndex(name, name, unique: false );现在，就可以从 name 找到对应的数据记录了。 var transaction = db.transaction([person], readonly);var store = transaction.objectStore(person);var index = store.index(name);var request = index.get(李四);request.onsuccess = function (e) var result = e.target.result; if (result) // ... else // ... ;","tags":["indexedDB"]},{"title":"防抖节流函数","path":"/2023/12/18/debounce-throttle/","content":"防抖 debounce - 重新开始应用场景：搜索框输入文字后调用对应搜索接口、文本编辑器实时保存 利用闭包，不管触发频率多高，在停止触发 n 秒后才会执行，如果重复触发，会清空之前的定时器，重新计时，直到最后一次 n 秒后执行 /* * @param function fn - 需要防抖的函数 * @param number time - 多长时间执行一次 * @param boolean flag - 第一次是否执行 */function debounce(fn, time, flag) let timer; return function (...args) // 在time时间段内重复执行，会清空之前的定时器，然后重新计时 timer clearTimeout(timer); if (flag !timer) // flag为true 第一次默认执行 fn.apply(this, args); timer = setTimeout(() = fn.apply(this, args); , time); ;function fn(a) console.log(执行:, a);let debounceFn = debounce(fn, 3000, true);debounceFn(1);debounceFn(2);debounceFn(3);// 先打印：执行: 1// 3s后打印: 执行: 3 节流 throttle - 不要打断我应用场景： 下拉滚动加载、快速点击、resize 事件，鼠标滑动、scroll 事件，视频播放记录时间等 利用闭包，不管触发频率多高，每隔一段时间内执行一次 /* * @param function fn - 需要防抖的函数 * @param number time - 多长时间执行一次 * @param boolean flag - 第一次是否执行 */function throttle(fn, time, flag) let timer; return function (...args) // flag控制第一次是否立即执行 if (flag) fn.apply(this, args); // 第一次执行完后，flag变为false；否则以后每次都会执行 flag = false; if (!timer) timer = setTimeout(() = fn.apply(this, args); // 每次执行完重置timer timer = null; , time); ;// 测试function fn() console.log(fn);let throttleFn = throttle(fn, 3000, true);setInterval(throttleFn, 500);// 测试结果，一开始就打印fn, 以后每隔3s打印一次fn","tags":["JS","性能优化"],"categories":["性能优化"]},{"title":"兼容性","path":"/2023/12/15/compatibility/","content":"经常遇到的浏览器的兼容性有哪些？ IE 浏览器不支持 Promisebabel-polyfill → webpack.config.js 的 entry 中设置 [‘babel-polyfill’, ‘.srcmain.js’] 各浏览器之间默认样式的差异normalize.css与 reset 区别 → normalize.css 消除各浏览器之间默认样式的差异、保留有用的默认样式；而 reset 会清除所有的默认样式，过于暴力，例如会让 h 标题标签不再默认加粗，ul li 前面默认的小圆点也没了） html5 某些新增标签不被识别html5shiv.js - 解决 ie9 以下对 html5 某些新增标签不识别的问题（e.g. video 标签不识别不显示）用法：[if lt IE 9] src=http://html5shim.googlecode.com/svn/trunk/html5.js![endif]通过 document.createElement 方法产生的标签， 可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。 CSS3 媒体查询失效respond.js - 能解决 ie9 以下不支持媒体查询问题 自动添加浏览器前缀posscss-loader+autoprefixer ie6 不支持 min-height/width添加额外的 _min-height ie6 识别 常见 hack（针对特定 ie 版本的样式控制）_color - ie6 识别*color - ie67 识别color: red\\9; ie8 及以下识别 ie 条件注释写法：(lt 小于 | gt 大于 | lte 小于等于 | gte 大于等于 | ! 不等于) 移动端兼容性？ 移动端点透问题(解决办法) ios 滚动卡顿使用 better-scroll 插件 ios 顶部输入框 fixed 布局失效（当键盘弹起时）❌ 安卓 键盘遮挡输入框 ❌ position:fixed; 在 android 下无效怎么处理？【❌ 待验证】 原因：fixed 的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的 viewport ， 原来的网页还好好的在那，fixed 的内容也没有变过位置。 解决： meta name=viewport content=width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no/ 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？❌click 有 300ms 延迟,为了实现 safari 的双击事件的设计，浏览器要知道你是不是要双击操作。 Polyfill什么是 Polyfillpolyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。 例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象， 所有这些都是 W3C 地理位置 API 定义的对象和函数。 因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发， 一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。 做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？❌比如： html5shiv、Geolocation、Placeholder 列举 IE 与其他浏览器不一样的特性？事件目标对象 触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性 获取字符代码 如果按键代表一个字符（shift、ctrl、alt 除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性 阻止某个事件的默认行为 IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法 停止事件冒泡 IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()","tags":["浏览器"]},{"title":"react和Vue中的key","path":"/2023/12/10/react-key/","content":"在 React 或 Vue 项目中，在列表组件中为每个列表项指定一个唯一的 key 是很重要的，其作用主要有以下几点： 优化性能：在进行列表渲染时，React 和 Vue 都会使用虚拟 DOM（Virtual DOM）来比较新旧 DOM 树，从而确定需要更新的部分。使用 key 可以帮助 React 或 Vue 识别每个列表项的身份，从而更准确地确定哪些列表项需要更新，从而优化渲染性能。 避免重复元素：如果列表项没有指定唯一的 key，当列表中的元素发生增删操作时，React 或 Vue 可能会错误地将新元素与旧列表中的元素混淆，导致不正确的更新或重复渲染相同的元素。 保持组件状态：在 React 中，当组件重新渲染时，React 会尽量保持每个元素的状态不变，即使元素的位置发生了变化。通过为每个列表项指定唯一的 key，React 可以更好地跟踪元素的状态，从而确保组件的状态正确地保持在每个列表项上。 便于查找和调试：使用 key 可以使得列表项在 React 或 Vue 的开发者工具中更易于查找和调试。你可以通过 key 来追踪每个列表项的变化，更好地理解渲染逻辑，并快速定位问题。 因此，无论是在 React 还是 Vue 项目中，在列表组件中为每个列表项指定一个唯一的 key 是很重要的，它能够提高性能、避免问题、保持组件状态，并且方便调试。","tags":["React"]},{"title":"什么操作可以造成内存泄露","path":"/2023/12/09/memory-leak/","content":"由于疏忽或者错误造成程序未能释放已经不再使用的内存，不再用到的内存却没有及时释放，从而造成内存上的浪费。 原因意外的全局变量由于 js 对未声明变量的处理方式是在全局对象上创建该变量的引用。如果在浏览器中，全局对象就是 window 对象。变量在窗口关闭或重新刷新页面之前都不会被释放，如果未声明的变量缓存大量的数据，就会导致内存泄露。 未声明变量 function fn() a = global variable;fn(); 使用 this 创建的变量(this 的指向是 window)。 function fn() this.a = global variable;fn(); 解决方法 避免创建全局变量 使用严格模式，在 Javascript 文件头部或函数的顶部加上 use strict 闭包引起的内存泄露闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中。如果在使用结束后没有将局部变量清除，就可能导致内存泄露。 function fn() var a = Im a; return function () console.log(a); ; 解决： 将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中。 比如：在循环中的函数表达式，能复用最好放到循环外面。 // badfor (var k = 0; k 10; k++) var t = function (a) // 创建了10次 函数对象。 console.log(a); ; t(k);// goodfunction t(a) console.log(a);for (var k = 0; k 10; k++) t(k);t = null; 没有清理的 DOM 元素引用虽然别的地方删除了，但是对象中还存在对 dom 的引用。 // 在对象中引用DOMvar elements = btn: document.getElementById(btn),;function doSomeThing() elements.btn.click();function removeBtn() // 将body中的btn移除, 也就是移除 DOM树中的btn document.body.removeChild(document.getElementById(button)); // 但是此时全局变量elements还是保留了对btn的引用, btn还是存在于内存中,不能被GC回收 解决： 手动删除，elements.btn = null 被遗忘的定时器或者回调定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom // 定时器var serverData = loadData();setInterval(function () var renderer = document.getElementById(renderer); if (renderer) renderer.innerHTML = JSON.stringify(serverData); , 5000);// 观察者模式var btn = document.getElementById(btn);function onClick(element) element.innerHTMl = Im innerHTML;btn.addEventListener(click, onClick); 解决： 手动删除定时器和 dom。 removeEventListener 移除事件监听","tags":["JS"]},{"title":"排序算法","path":"/2023/11/25/sort/","content":"const swap = (arr,i,j) = [arr[i],arr[j]] = [arr[j],arr[i]]; 冒泡排序比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 function bubbleSort(arr) var len = arr.length; for (var i = 0; i len - 1; i++) for (var j = 0; j len - 1 - i; j++) if (arr[j] arr[j + 1]) // 相邻元素两两对比 swap(arr, j, j + 1); return arr; 选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 function selectionSort(arr) var len = arr.length; var minIndex, temp; for (var i = 0; i len - 1; i++) minIndex = i; for (var j = i + 1; j len; j++) if (arr[j] arr[minIndex]) // 寻找最小的数 minIndex = j; // 将最小数的索引保存 swap(arr, i, minIndex); return arr; 插入排序将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） function insertionSort(arr) var len = arr.length; var preIndex, current; for (var i = 1; i len; i++) preIndex = i - 1; current = arr[i]; while (preIndex = 0 arr[preIndex] current) arr[preIndex + 1] = arr[preIndex]; preIndex--; arr[preIndex + 1] = current; return arr; 希尔排序选择一个增量序列 t1，t2，……，tk，其中 ti tj, tk 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 function shellSort(arr) var len = arr.length, temp, gap = 1; while (gap len / 3) //动态定义间隔序列 gap = gap * 3 + 1; for (gap; gap 0; gap = Math.floor(gap / 3)) for (var i = gap; i len; i++) temp = arr[i]; for (var j = i - gap; j = 0 arr[j] temp; j -= gap) arr[j + gap] = arr[j]; arr[j + gap] = temp; return arr; 归并排序 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 function mergeSort(arr) // 采用自上而下的递归方法 var len = arr.length; if (len 2) return arr; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));function merge(left, right) var result = []; while (left.length right.length) if (left[0] = right[0]) result.push(left.shift()); else result.push(right.shift()); while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result; 快速排序 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； function quickSort(arr, left, right) var len = arr.length, partitionIndex, left = typeof left != number ? 0 : left, right = typeof right != number ? len - 1 : right; if (left right) partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); return arr;function partition(arr, left, right) // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i = right; i++) if (arr[i] arr[pivot]) swap(arr, i, index); index++; swap(arr, pivot, index - 1); return index - 1;function partition2(arr, low, high) let pivot = arr[low]; while (low high) while (low high arr[high] pivot) --high; arr[low] = arr[high]; while (low high arr[low] = pivot) ++low; arr[high] = arr[low]; arr[low] = pivot; return low;function quickSort2(arr, low, high) if (low high) let pivot = partition2(arr, low, high); quickSort2(arr, low, pivot - 1); quickSort2(arr, pivot + 1, high); return arr;function quickSort3(arr, left = 0, right = arr.length - 1) if (arr.length 1) // lineIndex表示下一次划分左右子数组的索引位 const lineIndex = partition(arr, left, right); // 如果左边子数组的长度不小于1，则递归快排这个子数组 if (left lineIndex - 1) quickSort(arr, left, lineIndex - 1); // 如果右边子数组的长度不小于1，则递归快排这个子数组 if (lineIndex right) quickSort(arr, lineIndex, right); return arr;// 以基准值为轴心，划分左右子数组的过程function partition3(arr, left, right) // 基准值默认取中间位置的元素 let pivotValue = arr[Math.floor(left + (right - left) / 2)]; let i = left; let j = right; // 当左右指针不越界时，循环执行以下逻辑 while (i = j) // 左指针所指元素若小于基准值，则右移左指针 while (arr[i] pivotValue) i++; // 右指针所指元素大于基准值，则左移右指针 while (arr[j] pivotValue) j--; // 若i=j，则意味着基准值左边存在较大元素或右边存在较小元素，交换两个元素确保左右两侧有序 if (i = j) swap(arr, i, j); i++; j--; // 返回左指针索引作为下一次划分左右子数组的依据 return i;","tags":["算法"]},{"title":"CI/CD","path":"/2023/11/19/CICD/","content":"什么是 CICDCICD（Continuous Integration and Continuous Deployment，持续集成和持续部署）是一种软件开发实践，旨在通过自动化软件构建、测试和部署过程，以便快速、频繁地将代码交付给生产环境。CICD 流程包括持续集成（Continuous Integration，CI）、持续交付（Continuous Delivery，CD）和持续部署（Continuous Deployment，CD）。 **持续集成（CI）**是指开发人员频繁地将代码集成到共享的代码仓库中，并通过自动化构建和测试过程来验证代码的质量。这有助于减少集成问题、加快开发周期，并增强团队的协作。 **持续交付（CD）**是指在通过持续集成验证后，自动地将代码部署到预发布环境中，以便进行进一步的测试和验证。持续交付可以确保软件的可靠性和稳定性，并使团队能够更快地将新功能交付给用户。 **持续部署（CD）**是指在通过持续交付验证后，自动地将代码部署到生产环境中，以便向用户交付新功能和修复 bug。持续部署可以加快软件交付速度，并降低交付的风险。 要配置 CICD 流程，可以使用各种工具和平台，如 Jenkins、GitLab CICD、Travis CI、CircleCI 等。通常，配置 CICD 流程需要以下步骤： 版本控制：将代码托管到版本控制系统中，如 Git，确保团队成员可以共享和协作开发代码。 自动化构建：设置自动化构建过程，包括编译代码、运行单元测试、生成构建产物等。这可以通过构建工具如 Maven、Gradle、Webpack 等来实现。 自动化测试：编写自动化测试脚本，包括单元测试、集成测试、端到端测试等，确保代码的质量和可靠性。 持续集成：设置持续集成服务器，如 Jenkins，在代码提交后自动触发构建和测试过程，以验证代码的正确性。 持续交付：在通过持续集成验证后，设置持续交付流程，自动将代码部署到预发布环境中进行进一步的测试和验证。 持续部署：在通过持续交付验证后，设置持续部署流程，自动将代码部署到生产环境中，向用户交付新功能和修复 bug。 监控和反馈：设置监控和日志记录机制，及时发现和解决生产环境中的问题，并收集用户反馈以改进产品。 通过配置 CICD 流程，团队可以实现快速、可靠和持续地交付高质量的软件，提高开发效率和用户满意度。 一段简单的 CICD 配置以下是一个简单的 CICD 配置示例，使用了 GitHub 作为版本控制系统，Jenkins 作为持续集成工具，和 Docker 作为容器化部署的工具。这个配置会在代码提交后，自动触发构建、测试和部署流程。 GitHub 配置： 在 GitHub 上创建一个新的代码仓库，并将你的代码上传到仓库中。 Jenkins 配置： 在 Jenkins 中创建一个新的 Pipeline 项目，并将 GitHub 仓库链接到该项目。在项目配置中，设置触发器，选择 GitHub Webhook 触发器，并添加 GitHub 仓库的 URL 和身份验证信息。编写 Jenkinsfile，定义 Pipeline 的各个阶段和步骤，例如拉取代码、构建、测试、打包等。 pipeline agent any stages stage(Checkout) steps // 拉取代码 git https://github.com/your-repo.git stage(Build) steps // 构建应用程序 sh npm install // 举例：使用npm进行构建 stage(Test) steps // 运行自动化测试 sh npm test // 举例：使用npm运行测试 stage(Deploy) steps // 部署应用程序 sh npm run deploy // 举例：使用npm运行部署脚本 post always // 清理工作目录 cleanWs() 自动化测试： 在代码仓库中编写自动化测试脚本，包括单元测试、集成测试等。在 Jenkinsfile 中添加测试阶段，调用自动化测试脚本执行测试，并根据测试结果决定是否继续下一步。 Docker 配置： 编写 Dockerfile，定义 Docker 镜像的构建过程，包括基础镜像、依赖安装、应用程序部署等。在 Jenkinsfile 中添加 Docker 构建和部署阶段，使用 Docker 命令构建镜像并推送到镜像仓库，然后在目标服务器上拉取镜像并运行容器。 # 使用官方 Node.js 14 镜像作为基础镜像FROM node:14# 设置工作目录WORKDIR /app# 复制 package.json 和 package-lock.json 到工作目录COPY package*.json ./# 安装项目依赖RUN npm install# 将应用程序代码复制到工作目录COPY . .# 暴露端口EXPOSE 3000# 定义容器启动命令CMD [npm, start] 触发构建： 提交代码到 GitHub 仓库中，Jenkins 会收到 Webhook 通知并自动触发 Pipeline 项目的构建流程。Jenkins 会根据 Jenkinsfile 中定义的流程执行构建、测试和部署过程，最终将应用程序部署到目标服务器上。 这只是一个简单的 CICD 配置示例，实际的配置可能会更加复杂，涉及到更多的流程、工具和环境。但是通过这个示例，你可以了解到 CICD 配置的一般流程和步骤，以及如何使用 Jenkins、GitHub 和 Docker 等工具来实现自动化的构建、测试和部署流程。","categories":["前端质量保障"]},{"title":"Dom树怎么形成","path":"/2023/09/20/generate-dom/","content":"当浏览器加载 HTML 文档时，它会执行一系列步骤来解析文档并构建 DOM 树。这个过程可以分为以下几个阶段： 字节流转换为字符流：首先，浏览器会将接收到的字节流（例如从服务器传输过来的数据）转换为字符流。这个过程通常涉及到字符编码的转换，例如将字节流解码成 UTF-8 字符流。 词法分析（Tokenization）：接着，浏览器将字符流分解成一个个标记（Token），这个过程称为词法分析。标记通常对应 HTML 文档中的词法单元，比如元素、属性、文本内容等。词法分析器会识别出标签、属性和文本等各种不同类型的标记，并且为每个标记分配一个标识符。 构建节点对象：一旦词法分析完成，浏览器就会根据这些标记构建 DOM 节点对象。每个 HTML 元素对应一个 DOM 节点，每个 DOM 节点都有相应的属性和方法。节点之间的关系由标记之间的层级关系来确定。例如，标签内的文本会成为该标签的子节点。 构建 DOM 树：接下来，浏览器将构建的 DOM 节点组织成一棵树，这棵树就是 DOM 树。DOM 树的根节点是html元素，它的子节点包括head和body等。根据 HTML 文档的结构，DOM 树的每个节点都有相应的父节点和子节点。 CSS 解析和样式计算：一旦 DOM 树构建完成，浏览器会继续解析外部 CSS 样式表和内部样式，并将这些样式应用到 DOM 树上的相应节点。这个过程称为样式计算，它会确定每个节点的最终样式。 渲染页面：最后，浏览器将 DOM 树和样式表结合起来，计算每个节点的布局信息，并将页面的内容绘制到屏幕上。这个过程称为页面渲染，它包括计算布局、绘制文本和图形等操作，最终呈现出用户所看到的页面。 通过这些步骤，浏览器可以将 HTML 文档解析并渲染成用户可见的页面，同时构建出一棵表示页面结构和内容的 DOM 树，开发者可以通过 JavaScript 来操作这棵树，实现页面的动态交互和更新。","tags":["JS"]},{"title":"http协议","path":"/2023/09/08/http/","content":"怎么知道网站用的 http 协议版本？F12- network -右击 Tab,勾选 Protocal HTTP 和 HTTPS 的区别s HTTP: 超文本传输协议 端口 ：80 明文传输，没有数据加密，不安全 不需要证书 HTTPS: 超文本传输安全协议 端口： 443 SSLTLS 加密传输协议 https 需要 ca 证书，一般没有免费证书，需要一定的费用 HTTPS 的机密HTTPS 的加密使用了对称加密和非对称加密的组合 HTTPS 加密的工作流程 建立连接 客户端向服务器发送连接请求。 服务器响应，并返回其 SSL 证书，其中包含了公钥。 验证证书 客户端收到服务器的证书后，会验证证书的有效性。这包括检查证书是否由受信任的证书颁发机构（CA）签发，以及是否在有效期内。 如果证书有效，则客户端生成一个随机的对称密钥，并使用服务器的公钥对其进行加密，然后将其发送回服务器。 建立安全连接 服务器接收到客户端发送的加密后的对称密钥，并使用私钥解密。 之后，客户端和服务器都拥有了相同的对称密钥，用于加密和解密通信内容。 安全通信 客户端和服务器使用这个对称密钥来加密和解密其之间的通信数据。 通信数据在传输过程中保持加密状态，从而防止被窃听或篡改。 关于加密过程中使用的加密算法： 对称加密：对称加密使用相同的密钥进行加密和解密。在 HTTPS 连接建立过程中，对称加密算法用于加密实际的数据传输，因为对称加密算法通常速度较快，适合大量数据的加密和解密。 非对称加密：非对称加密使用一对密钥，即公钥和私钥。公钥用于加密数据，私钥用于解密数据。在 HTTPS 连接建立过程中，服务器的公钥用于加密客户端生成的对称密钥，确保只有服务器持有对应的私钥才能解密对称密钥，从而保证通信的机密性。 HTTP1.1、 HTTP2、HTTP3HTTP1.1HTTP1.1 是最早的标准化版本，最初定义于 RFC 2616。 特点： 每次请求都需要建立新的 TCP 连接。 串行传输：在同一连接上，客户端和服务器一次只能发送一个请求或响应。 阻塞：某个请求响应的延迟会阻塞后续请求响应。 头部冗余：每个请求都会携带相同的头部信息。 缺点： 性能瓶颈：多个资源请求会受到连接数限制，影响性能。 网络利用率低：因为串行传输和头部冗余，导致网络利用率低下。 HTTP2HTTP2 是 HTTP1.1 的进化版本，通过 Google 的 SPDY 协议演化而来，目前由 RFC 7540 定义。 特点： 多路复用：在同一连接上，允许多个请求和响应同时交错传输。 头部压缩：减少了头部信息的大小，降低了数据传输量。 服务器推送：服务器可以主动向客户端推送资源，提高性能。 优化流程：通过二进制协议优化了数据传输流程。 优点： 性能提升：多路复用和头部压缩等特性大幅提高了性能。 资源利用率提高：同一连接上多个请求共享资源，提高了网络利用率 HTTP3HTTP3 是基于 UDP 的新协议，旨在进一步提高性能，由 IETF 的 QUIC 协议演化而来。 特点： 基于 UDP：通过 QUIC 协议实现，使用 UDP 作为传输层协议，避免 TCP 的一些限制。 多路复用：与 HTTP2 类似，支持在同一连接上并行传输多个请求和响应。 0-RTT：支持 0-RTT（零往返时间），可以更快地建立连接和传输数据。 抗丢包：QUIC 实现了自己的流量控制和拥塞控制，更好地适应了丢包情况。 优点：进一步提高性能：通过 UDP 和其他优化，进一步提高了性能和可靠性。减少网络延迟：支持 0-RTT 可以减少连接建立时间，降低延迟。 总的来说，HTTP2 在 HTTP1.1 的基础上引入了多路复用和头部压缩等特性，大幅提升了性能。而 HTTP3 则在 HTTP2 的基础上进一步通过使用 UDP 和其他优化提高了性能和可靠性，尤其在面对高延迟和丢包的网络环境下具有优势。","tags":["http"]},{"title":"虚拟列表","path":"/2023/08/10/virtual-list/","content":"前端的虚拟列表（Virtual List）是一种优化大型数据列表性能的技术。当需要在网页或应用程序中展示大量数据时，传统的方式是一次性渲染所有数据，这可能导致页面加载缓慢和性能下降。虚拟列表通过只渲染用户可见区域内的数据项，以及动态地加载和卸载数据项，来解决这个问题 怎么做？ 分页显示：虚拟列表将数据分页显示，只渲染用户当前可见区域内的数据项，而不是一次性渲染所有数据。 动态加载：随着用户滚动页面或列表，虚拟列表会根据用户的滚动位置，动态地加载新的数据项进入可见区域，同时卸载不再可见的数据项，以减少渲染开销。 缓存机制：为了提高性能，虚拟列表通常会采用缓存机制，预先渲染一些超出可见区域的数据项，以便在用户滚动时能够快速显示。 列表项高度统一化：为了更好地计算和控制可见区域内的数据项，虚拟列表通常要求所有列表项的高度是统一的，或者能够以某种方式被统一。 优点 性能优化：虚拟列表可以极大地提升页面或应用程序对大型数据列表的性能表现，减少初始化和渲染时间，提高用户体验。 内存消耗低：由于只渲染可见区域的数据项，虚拟列表可以大大降低内存消耗，尤其在处理大数据量时尤为明显。 流畅滚动：通过动态加载和卸载数据项，虚拟列表可以实现流畅的滚动效果，即使数据量很大也能够保持良好的性能。 缺点 复杂性：实现虚拟列表可能需要较高的技术要求，涉及到数据分页、滚动监听、缓存管理等复杂逻辑，增加了开发的复杂性。 不适用于所有场景：虽然虚拟列表适用于大型数据列表的展示，但在一些特定场景下，例如列表项高度不固定或数据项需要频繁变动的情况下，虚拟列表可能不太适用。 滚动条问题：由于虚拟列表动态加载数据，可能会影响浏览器原生滚动条的行为，需要额外处理滚动事件以保证滚动体验的一致性。","tags":["性能优化"],"categories":["性能优化"]},{"title":"js中精度丢失问题","path":"/2023/06/26/precision-loss/","content":"JavaScript 精度丢失问题通常指的是浮点数精度丢失的情况，这是由于 JavaScript 中的浮点数采用 IEEE 754 标准表示，而该标准无法准确表示一些十进制小数。这可能导致在进行浮点数运算时出现意外的结果或精度损失。 0.1 + 0.2 // 返回0.30000000000000004 这种情况的出现是因为 0.1 和 0.2 的二进制表示无法精确地表示为有限位数的浮点数，因此在进行加法运算时会产生微小的误差。 为了解决 JavaScript 中的精度丢失问题，可以采用以下方法之一： 避免直接比较浮点数：在比较浮点数时，尽量避免直接使用相等运算符（例如 ），而是使用一个误差范围来比较，例如： const epsilon = 0.000001;Math.abs(0.1 + 0.2 - 0.3) epsilon; // true 使用专门的库：一些专门的 JavaScript 库（例如 BigNumber.js）提供了高精度的数学运算，可以避免浮点数精度丢失的问题。 转换为整数处理：在一些情况下，将浮点数转换为整数处理可以避免精度丢失问题，例如乘以一个适当的倍数后进行整数运算，然后再将结果转换回浮点数。 const floatNumber = 0.1 + 0.2;// 定义一个倍数（可以是 10 的幂，根据需要调整）const multiplier = 1000000;// 将浮点数乘以倍数并转换为整数const integerNumber = Math.round(floatNumber * multiplier);const result = integerNumber + 12345;// 将结果再除以相同的倍数来还原为原始的浮点数const finalResult = result / multiplier;console.log(finalResult); // 0.300012345 使用 toFixed()方法：在显示浮点数时，可以使用 toFixed() 方法将浮点数转换为指定小数位数的字符串，以避免精度丢失问题： const number = 0.1 + 0.2;const fixedNumber = (0.1 + 0.2).toFixed(2); // 将结果四舍五入到小数点后两位console.log(fixedNumber); // 输出 0.30","tags":["JS"]},{"title":"闭包","path":"/2023/06/20/closure/","content":"闭包是指函数与其词法环境的组合，函数可以访问其词法作用域中的变量，即使在函数定义之后执行也可以访问到。闭包可以在函数内部创建私有变量，并且可以通过返回函数或传递函数作为参数的方式，将这些私有变量暴露给外部作用域。闭包是 JavaScript 中非常强大和常用的特性，它能够帮助开发者实现许多功能，例如模块化、封装、延迟执行等。 以下是闭包的常用场景： 1. 封装私有变量：使用闭包可以创建具有私有变量的函数，这些变量对外部代码是不可见的。通过在函数内部定义变量，并在返回的函数中引用这些变量，可以实现私有变量的封装，防止外部代码直接访问和修改。 function createCounter() let count = 0; return function () return ++count; ;const counter = createCounter();console.log(counter()); // 1console.log(counter()); // 2 2. 模块化开发：闭包可以用于实现模块化开发，通过将模块的功能封装在闭包中，并返回一个包含公共接口的对象或函数，从而隐藏模块内部的实现细节，只暴露必要的方法或属性给外部使用。 const calculator = (function () function add(a, b) return a + b; function subtract(a, b) return a - b; return add: add, subtract: subtract, ;)();console.log(calculator.add(5, 3)); // 8console.log(calculator.subtract(5, 3)); // 2 3. 事件处理程序：闭包常用于事件处理程序中，可以在事件处理函数中访问外部作用域的变量。这种方式使得事件处理程序可以访问和修改定义事件处理程序的函数中的变量，而不需要将这些变量暴露给全局作用域。 function createButton() let count = 0; const button = document.createElement(button); button.textContent = Click me; button.addEventListener(click, function () count++; console.log(`Button clicked $count times`); ); return button;const button = createButton();document.body.appendChild(button); 4. 延迟执行：闭包可以用于实现延迟执行，即将一个函数作为参数传递给另一个函数，并在需要时调用该函数。由于闭包可以访问外部作用域的变量，因此可以在内部函数中引用外部作用域的变量。 function delay(callback, milliseconds) setTimeout(callback, milliseconds);delay(function () console.log(Delayed message);, 1000); 这些是闭包的一些常用场景，闭包在 JavaScript 中被广泛应用于函数式编程、模块化开发、事件处理、异步编程等方面，是 JavaScript 中非常重要和强大的特性之一。","tags":["JS"]},{"title":"CSS纵享丝滑滚动","path":"/2023/06/18/css-slide/","content":"我们之前利用 a 标签的锚点功能，能让页面滚动到指定位置，但是存在顿挫感，使用scroll-behavior: smooth;可以让滚动变得丝滑。 CSS 实现!DOCTYPE htmlhtml lang=en head meta charset=UTF-8 / meta name=viewport content=width=device-width, initial-scale=1.0 / titleDocument/title style .box1 background-color: aqua; width: 1000px; height: 600px; margin: 80px 20px; .box2 background-color: rgb(0, 255, 13); width: 1000px; height: 600px; margin: 80px 20px; .box3 background-color: rgb(227, 154, 177); width: 1000px; height: 600px; margin: 80px 20px; .slidebar position: fixed; top: 50%; right: 0; transform: translateY(-50%); .slidebar a width: 80px; height: 80px; display: flex; justify-content: center; align-items: center; .slidebar a:first-child background-color: aqua; .slidebar a:nth-child(2) background-color: rgb(0, 255, 13); .slidebar a:last-child background-color: rgb(227, 154, 177); html /* 页面滚动条滑动 */ scroll-behavior: smooth; /style /head body div class=box1 id=box1服饰/div div class=box2 id=box2家电/div div class=box3 id=box3生鲜/div div class=slidebar a href=#box1服饰/a a href=#box2家电/a a href=#box3生鲜/a /div /body/html 但是 scroll-behavior 的兼容性会很差，比如在移动端 ios 基本不支持，我们也可以用 JS 来实现 JS 实现target.scrollIntoView( behavior: smooth,);","tags":["CSS"]},{"title":"深拷贝","path":"/2023/04/08/deepClone/","content":"手写深拷贝 /** * 深拷贝 * @param Object obj 要拷贝的对象 * @param Map map 用于存储循环引用对象的地址 */function deepClone(obj = , map = new Map()) if (typeof obj !== object) return obj; if (map.get(obj)) return map.get(obj); let result = ; // 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此 if (obj instanceof Array || Object.prototype.toString === [object Array]) result = []; // 防止循环引用 map.set(obj, result); for (const key in obj) // 保证 key 不是原型属性 if (obj.hasOwnProperty(key)) // 递归调用 result[key] = deepClone(obj[key], map); return result;","tags":["JS"]},{"title":"对称加密和非对称加密","path":"/2023/02/19/encryption/","content":"对称加密对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥加密。 也就是密钥也可以用作解密密钥，这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比 DES 的加密性好，而且对计算机功能要求也没有那么高 对称加密算法在电子商务交易过程中存在几个问题：1、要求提供一条安全的渠道使通讯双方在首次通讯时协商一个共同的密钥。直接的面对面协商可能是不现实而且难于实施的，所以双方可能需要借助于邮件和电话等其它相对不够安全的手段来进行协商； 2、密钥的数目难于管理。因为对于每一个合作者都需要使用不同的密钥，很难适应开放社会中大量的信息交流； 3、对称加密算法一般不能提供信息完整性的鉴别。它无法验证发送者和接受者的身份； 4、对称密钥的管理和分发工作是一件具有潜在危险的和烦琐的过程。对称加密是基于共同保守秘密来实现的，采用对称加密技术的贸易双方必须保证采用的是相同的密钥，保证彼此密钥的交换是安全可靠的，同时还要设定防止密钥泄密和更改密钥的程序。 假设两个用户需要使用对称加密方法加密然后交换数据，则用户最少需要 2 个密钥并交换使用，如果企业内用户有 n 个，则整个企业共需要 n×(n-1) 个密钥，密钥的生成和分发将成为企业信息部门的恶梦。 常见的对称加密算法有 DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 和 AES 非对称加密与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。 公钥用于加密数据，私钥用于解密数据。这意味着公钥可以公开分享，而私钥必须保持机密。 公钥用于加密的数据只能使用相应的私钥进行解密，这使得非对称加密适合用于安全通信和数字签名等场景 常见的非对称加密算法包括 RSA（Rivest-Shamir-Adleman）、DSA（Digital Signature Algorithm）、ECC（Elliptic Curve Cryptography）等。 非对称加密算法实现机密信息交换的基本过程甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。 区别1、对称加密中加密和解密使用的秘钥是同一个；非对称加密中采用两个密钥，一般使用公钥进行加密，私钥进行解密。 对称加密的加密过程和解密过程使用的同一个密钥，加密过程相当于用原文+密钥可以传输出密文，同时解密过程用密文-密钥可以推导出原文。但非对称加密采用了两个密钥，一般使用公钥进行加密，使用私钥进行解密。 2、对称加密解密的速度比较快，非对称加密和解密花费的时间长、速度相对较慢。 对称加密解密的速度比较快，适合数据比较长时的使用。非对称加密和解密花费的时间长、速度相对较慢，只适合对少量数据的使用。 3、对称加密的安全性相对较低，非对称加密的安全性较高。 对称加密的过程中无法确保密钥被安全传递，密文在传输过程中是可能被第三方截获的，如果密码本也被第三方截获，则传输的密码信息将被第三方破获，安全性相对较低。 非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。所以安全性较高。","tags":["http"]},{"title":"service worker","path":"/2023/02/19/service-worker/","content":"了解 service work 前先了解一下 PWA，那么什么是 PWA 呢？ 渐进式网路应用 PWA Web 应用和 Native 应用有着各自不同的优势和使用场景 PWA 结合了二者的优势 PWA 会越来越流行 Web 应用的资源存储在服务器，Native 的资源存储在本地。所以 Native 会比 Web 应用的加载速度和流畅性方面获得更好地表现； PWA 旨在创造拥有更加流畅的用户体验的 Web 应用，和创建类 Native App 的沉浸式效果，而非浏览器端那样的外观和体验； 在各种网络和数据加载的条件下仍然可用－它可以在网络不稳定或者没有网络的情况下使用。 基本架构Service Worker 是 PWA 的关键技术，可以支持一些原始应用的功能 友好的弱网和离线体验 定期的后台同步 推送通知 Service workers 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。 1.友好的弱网和离线体验这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用来采取适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。 web worker JavaScript 是一个单线程的语言； 异步编程通过调度一部分代码在 event loop 中执行，从而让程序流畅地运行； Web Workers 是真正的多线程 Service Worker 是 Web Worker 的一个子类 webpack 最常见的应用是耗时的计算，比如可视化操作，绘画，web 游戏，电子表单那种上万的数据 script setuplet worker = new Worker(http://localhots:5157/list.js, type: module,);worker.addEventListener(message, (e) = console.log(e.data););/scripttemplate button @click= () = worker.postMessage( a: 123, ); 发消息给worker /button/template // list.jslet a = 1 + 1;self.postMessage(a);self.addEventListener(message, (e) = console.log(e); self.postMessage(收到);); 特性 它是一种 Web worker，不能直接访问 DOM 它有自己独立的生命周期，不和特定网页相关联 是一个由事件驱动的 worker，它由源和路径组成 可以使用一些离线存储 API — Cache Storage 和 IndexedDB, 不能访问 localStorage 大量使用了 Promise 只能使用 HTTPS，localhost 也被允许 生命周期 Service Worker 的生命周期和网页是相互独立的 在网页的 JS 代码中调用 Service Worker 的注册方法开始安装。在安装阶段可以进行一些缓存工作，缓存失败安装就会失败。如果安装成功，代表了缓存也成功完成了 安装成功后触发 activate 事件，Service Worker 处于激活状态 激活后的 Service Worker 线程可以控制页面、监听事件了，它可以根据情况被中止或者唤起 基本功能和用法 install 事件会在注册完成之后触发。install 事件一般是被用来填充你的浏览器的离线缓存能力。 为了达成这个目的，我们使用了 Service Worker 的新的标志性的存储 API — cache — 一个 service worker 上的全局对象，它使我们可以存储网络响应发来的资源，并且根据它们的请求来生成 key。在安装事件的回调里我们需要完成一些缓存的工作，所以需要 waitUntil() 方法来暂时挂起代码，waitUntil 方法接受一个promise。 使用 Cache API 缓存资源Cache 接口为缓存的 Request / Response 对象对提供存储机制 一个域可以有多个命名 Cache 对象。 你需要在你的脚本 (例如，在 ServiceWorker 中)中处理缓存更新的方式。除非明确地更新缓存，否则缓存将不会被更新；除非删除，否则缓存数据不会过期。 CacheStorage 接口表示 Cache 对象存储。 使用通过全局 caches 属性来访问 CacheStorage，可以在 window、Service Worker 中访问。 window.caches // CacheStorage 使用 CacheStorage.open(cacheName) 打开一个 Cache 对象，再使用 Cache 对象的方法去处理缓存。 activate 事件在脚本激活后触发，一般在这里处理旧版本的缓存fetch 事件监听客户端的请求，包括任何被 service worker 控制的文档和文档内引用的资源。配合 respondWith() 方法，可以劫持 HTTP 响应 CacheStorage.open() CacheStorage.keys() CacheStorage.match() Cache.addAll(requests) Cache.add(request) Cache.put(request,response) Cache.match(request) Cache.delete(request) 在 install 阶段缓存资源 打开缓存 缓存文件 确认是否所有的静态资源已缓存 self.addEventListener(install, (event) = event.waitUntil( caches.open(CACHE_NAME).then(function (cache) console.log(Opened cache); return cache.addAll(urlsToCache); ) );); 缓存运行时请求 event.respondWith() 会决定如何响应 fetch 事件。 caches.match() 查询请求及查找之前创建的缓存中是否有任意缓存结果并返回 promise。 如果有，则返回该缓存数据。 否则，执行 fetch 。 检查返回的状态码是否是 200。同时检查响应类型是否为 basic，即检查请求是否同域。当前场景不缓存第三方资源的请求。 把返回数据添加到缓存中。 self.addEventListener(fetch, function (event) event.respondWith( caches.match(event.request).then(function (response) if (response) return response; //复制请求。请求是一个流且只能被使用一次。因为之前已经通过缓存使用过一次了，所以为了在浏览器中使用fetch，需要复制下该请求。 var fetchRequest = event.request.clone(); //没有找到缓存。所以我们需要执行 fetch 以发起请求并返回请求数据。 return fetch(fetchRequest).then(function (response) //检测返回数据是否有效 if (!response || response.status !== 200 || response.type !== basic) return response; //复制返回数据，因为它也是流。因为我们想要浏览器和缓存一样使用返回数据，所以必须复制它。这样就有两个流 var responseToCache = response.clone(); caches, open(CACHE_NAME).then(function (cache) //把请求添加到缓存中以备之后的查询用 cache.put(event.request, responseToCache); ); return response; ); ) );); 更新 Service Worker当用户访问网络应用的时候，浏览器会在后台重新下载包含 Service Worker 代码的 .js 文件。如果下载下来的文件和当前的 Service Worker 代码文件不同，浏览器会认为文件发生了改变并且会创建一个新的 Service Worker。 创建新的 Service Worker 的过程将会启动，然后触发 install 事件。然而，这时候，旧的 Service Worker 仍然控制着网络应用的页面意即新的 Service Worker 将会处于 waiting 状态。 一旦关闭网络应用当前打开的页面，旧的 Service Worker 将会被浏览器杀死而新安装的 Service Worker 就可以上位了。这时候将会触发 activate 事件。 这是为了避免在不同选项卡中同时运行不同版本的的网络应用所造成的问题－一些在网页中实际存在的问题且有可能会产生新的 bug（比如当在浏览器中本地存储数据的时候却拥有不同的数据库结构）。 在 activate 阶段清理旧版本的缓存出现在 activate 回调中的一个常见任务是缓存管理。 这么做的原因是，如果在安装步骤中清除了任何旧缓存，则继续控制所有当前页面的任何旧 Service Worker 将突然无法从缓存中提供文件。 //清除了旧版本的缓存self.addEventListener(activate, function (event) event.waitUntil( caches.keys().then(function (cacheNames) return Promise.all( cacheNames.map(function (cacheName) if (!expectedCaches.includes(cacheNames)) return caches.delete(key); ) ); ) );); 如何在浏览器里面进行调试Update on reload 重新提取 Service Worker。 即使字节完全相同，也将其作为新版本安装，这表示运行 install 事件并更新缓存。 跳过等待阶段，以激活新 Service Worker。 浏览页面。这意味着每次浏览时（包括刷新）都将进行更新，无需重新加载两次或关闭标签。 Offline 可以离线应用Bypass for network 可以绕过 Service Worker 的控制Disable cache 选项不会影响 Service Worker 的缓存；⌘ + ⇧ + R 强制刷新，会跳过 Service Worker 的控制； 打开 chrome://inspect/#service-workers 管理浏览器中的 Service Worker 参考资料：ChangbaFEpresentation","tags":["web"]},{"title":"js 手写函数","path":"/2023/02/13/js-handwriting-function/","content":"unshift()const arr = [1, 2.3];arr.myUnshift(4, 5, 6);Array.prototype.myUnshift = function () const len = arguments.length; for (let i = len - 1; i = 0; i--) this.slice(0, 0, arguments[i]); return this.length;;console.log(arr.myUnshift(4, 5, 6), arr); 去重//(method) Arrayany.indexOf(searchElement: any, fromIndex?: number | undefined): numberArray.prototype.myUnique = function () return this.filter((v, idx) = return this.indexOf(v, 0) === idx; );; 或 Array.prototype.myUnique = function () return [...new Set(this)];; 获取指定范围内的随机数function fn(min, max) //(min,max) // return Math.round(Math.random() * (max - min - 2) + (min + 1)); //[min,max] // return Math.round(Math.random() * (max - min ) + min); //(min,max) // return Math.ceil(Math.random() * (max - min) + (min)); //(min,max) return Math.floor(Math.random() * (max - min) + min); 打印 100 之内的质数let count;for (let i = 2; i 100; i++) for (let j = 1; j = i; j++) if (i % j === 0) count++; //质数只能被1和它本身整除 if (count === 2) console.log(i); count = 0; 如何提取 URL 中的参数const url = https://baidu.com?a=1b=2c=3#hash;function queryURLParams(URL) let url = URL.split(?)[1]; const urlSearchParams = new URLSearchParams(url); const params = Object.fromEntries(urlSearchParams.entries()); return params;console.log(queryURLParams(url)); 数组随机排序function result(arr) for (let i = 0; i arr.length; i++) let randomIndex = parseInt(Math.random() * arr.length); let curNum = arr[i]; arr[i] = arr[randomIndex]; arr[randomIndex] = curNum; return arr; 或 const arr = [1, 2, 3, 4, 5, 6, 7, 8];arr.sort(() = Math.random() - 0.5);console.log(arr); 实现迭代的方式实现 flattenlet arr = [1, 2, [3, 4, 5], 6, [7, [8, 9, [10, [11, 12]]]]];const flatten = function (arr) while (arr.some((v) = Array.isArray(v))) arr = [].concat(...arr); return arr;; 或 const flatten = function (arr) return [].concat(...arr.map((v) = (Array.isArray(v) ? flatten(v) : v)));; 两数之和 nums target const nums = [2, 7, 11, 17];const target = 9;function twoSum(nums, target) for (let i = 0; i nums.length; i++) const targetIndex = nums.indexOf(target - nums[i]); if (targetIndex -1 targetIndex !== i) return [i, targetIndex]; 给 a,b,c 三个请求，c 在 a,b 获取完数据之后再发送请求 1. promise.all const fs = require(fs);let arr = [];function fn(data) arr.push(data); if (arr.length === 2) console.log(arr); fs.readFile(./a.text, utf-8, (err, data) = fn(data););fs.readFile(./b.text, utf-8, (err, data) = fn(data);); 如何实现一个事件发布订阅class EventEmitter handlers = ; on(type, handler, once = false) if (!this.handlers[type]) this.handlers[type] = []; if (!this.handlers[type].includes(handler)) this.handlers[type].push(handler); handler.once = once; once(type, handler) this.on(type, handler, true); off(type, handler) if (this.handlers[type]) this.handlers[type] = this.handlers[type].filter((h) = h !== handler); trigger(type) if (this.handlers[type]) this.handlers[type].forEach((handler) = handler.call(this); if (handler.once) this.off(type, handler); ); const ev = new EventEmitter();function handler1() console.log(handler1);function handler2() console.log(handler2);function handler3() console.log(handler3);ev.on(test, handler1);ev.once(test, handler2);ev.on(test, handler3);ev.trigger(test);ev.trigger(test); apply、call、bindapplyFunction.prototype.myApply = function (context, args) context = context || window; context.fn = this; let result = context.fn(...args); delete context.fn; return result;; callFunction.prototype.myCall = function (context, ...args) context = context || window; context.fn = this; let result = context.fn(...args); delete context.fn; return result;; bindFunction.prototype.myBind = function (context, ...arg1) let that = this; return function (...arg2) return that.apply(context, [...arg1, ...arg2]); ;; Promise.allPromise.all = function (promises) return new Promise((resolve, reject) = if (typeof promises[Symbol.iterator] !== function) reject(Type error); if (promises.length === 0) resolve([]); else const res = []; let count = 0; const len = promises.length; for (let i = 0; i len; i++) Promise.resolve(promises[i]) .then((data) = res[i] = data; if (++count === len) resolve[res]; ) .catch((err) = reject(err); ); );; instanceoffunction myInstanceof(target, origin) if (typeof target !== object || target === null) return false; if (typeof origin !== function) throw new TypeError(origin must be function); let proto = Object.getPrototypeOf(target); while (proto) if (proto === origin.prototype) return true; proto = Object.getPrototypeOf(proto); return false; reduceArray.prototype.reduce = function (cb, initialValue) let arr = this, total = arr[0] || initialValue; for (let i = initialValue ? 0 : 1; i arr.length; i++) cb(total, arr[i], i, arr); return total;;","tags":["JS"]},{"title":"quick-sort","path":"/2023/01/23/quick-sort/","content":"基本思想 选定 Pivot 中心轴 将大于 Pivot 的数字放在 Pivot 的右边 将大于 Pivot 的数字放在 Pivot 的左边 分别对左右子序列重复前三步操作 存在两个下标，L 和 R，进行移动下标，与 Pivot 值进行比较，并移动位置，最终，L 和 R 相遇后，Pivot 值放在相遇的位置，完成一次排序，再以当前的位置划分左右两个序列，分别对两边的序列再重复排序操作","tags":["算法"]},{"title":"自动化测试","path":"/2023/01/15/auto-testing/","content":"目标为了更好的实施自动化测试，我们希望有一套简单但足够的自动化测试体系，能够从各个层面帮助我们开展自动化测试，从而交付高质量的软件代码。 本文包含三个部分，包括「测试流程」、「测试平台和工具」和「测试方法论」，各自关注不同的维度，整体形成一个良好的体系。 测试流程测试流程关注测试开发的过程中，应该以怎样的流程来实施，以便测试的最佳效果。 用例设计测试用例的设计需要考虑多个层面，尽量全方位的考虑所有场景，包括但不限于如下层面： 用户故事，特定功能需要满足的用户场景 权限需求，不同权限可能的差异 异常场景，一些异常可能出现的问题，如何恢复 兼容性，对环境、设备、浏览器的要求 性能层面，数据量是否很大，是否有极致的性能需求这上面的东西，是测试用例设计的需求，在需求明确之后，就可以针对它们设计具体的测试用例。 好的测试用例是一个完备的集合，覆盖所有等价类与关键值，设计好的测试用例有三种常用的方式： 等价类划 边界值 错误推测 具体步骤测试用例的设计可以分为以下几个步骤： 画一个较粗的业务流程图，包含所有的流程分支，图内每个节点可以较粗，比如“短信验证码登录”就是一个节点，先不用细分手机号是否已注册，或者对应的用户是什么身份。 我们把流程图中最长的主流程称为基本流 1，其他分支也依次标号，然后就可以组合出该流程图中所有可能的子流程，比如 1 + 2 + 4。○ 当流程图比较复杂导致组合情况过多时，可以寻找解耦点將它拆分为两个甚至多个彼此之间耦合度较低的流程图，也就是说一个流程以哪一条路径执行基本不影响另一个流程的正确性。然后对拆分后的流程图罗列组合。○ 我们可以进一步降低流程图的复杂度，不把“表单验证失败”的节点写在流程图中，每个表单的验证可以做成单独的测试用例。比如“短信验证码登录”的失败原因分为手机号格式不对、验证码错误、验证码过期等等，这些可以单独汇总在一个测试用例中去测试。 ～～对上述的组合结果进行精简，依然从耦合度的角度去考虑。假设我们的组合中有 1 + 2、1 + 3 和 1 + 2 + 3，而分支 3 的执行与否对分支 2 的正确性几无影响，那么在已测试 1 + 2 和 1 + 3 的基础上，1 + 2 + 3 的性价比非常低，对测试效果的提升很小，可以被精简掉。这个比较依赖设计者的经验去判断哪些是“无意义”的组合。～～○ 这一条先注释掉，不太好解释和实施，需要在实践中再打磨。 为精简后的每一个组合编写一个测试用例。对于用例中的每一个节点步骤，此时要考虑它的细分场景。比如“短信验证码登录”，需要先按业务场景拆分为学生登录、老师登录、家长登录、未注册手机号登录 4 种可能性。○ 原则上每一种可能性都应当是一个单独的测试用例，但为了不重复编写差别很小的用例，我们可以在一个用例中描述一个节点的多个输入值。在实际执行用例时，可以选择在一个节点上测试多个输入值再继续往下也可以每个输入值都跑一遍用例中的流程，这个也需要执行者依靠经验来灵活判断。○ 我们需要同时在测试用例管理工具中保存业务流程图，为执行者理解测试用例和设计者将来随着业务变化更新测试用例提供方便。○ 设计测试用例是一个再次检查产品逻辑严密性的好时机，遇到问题需要及时与产品经理沟通。○ 很多用例，尤其是表单验证类的，需要用等价类划分和边界值的方法去设计多种输入值。 然后设计者需要基于对业务的了解补充针对不在正常业务逻辑中的异常场景、安全性敏感场景、性能敏感场景的测试用例，就得到了完整的冒烟测试和黑盒测试集。○ 有些“副作用”式的功能可以考虑集中在一个测试用例中描述，比如任务的推送，可以写一个测试用例集中测试，包括任务的创建、修改、驳回等各种情况的推送。 最后我们需要根据黑盒测试集做 E2E UI 自动化测试，考虑到编写效率和运行效率，思路是一长多短：a. 在一个模块的用例中取一个最长的基本流先实现。b. 实现其他未被覆盖的短分支。 举个例子这是一个 App 用手机号登录后选择身份进入主页的流程图，按照上文我们提供的方法： 这个流程原本属于一个更长的流程，前面是手机号登录的流程，两部分加起来是一个完整的 App 登录流程，但是我们认为这个子流程之间的耦合度不高，所以选择了在中间解耦，变成两个流程分别测试。 在编写黑盒测试用例时，我们得到的组合集是：a. 1 - 2 - 3 - 4 - 5b. 1 - 4 - 5c. 1 - 4 - 3 - 4 - 5外加一个绑定新身份时的表单验证。 在编写 E2E UI 自动化测试时，我们先实现最长基本流，然后实现剩下的短分支，所以最后编写的用例是：a. 1 - 2 - 3 - 4 - 5b. 1 - 4 - 5c. 1 - 4 - 3 测试规划在需求明确之后，有大致的测试用例之后，应该对测试的实施有一个大致的规划，一定程度的明确各个类型的测试做多少，怎么做。 比如对于复杂的项目，我们可能需要更多的单元测试，从而保证逻辑的正确性，对于简单的项目，可能一定的功能测试和 E2E 测试就可以了。 测试规划的时候，应该考虑到各种测试类型擅长的和不擅长的，合理安排比例以及覆盖场景，在成本可控的前提下实现效率的最大化。\b 测试开发规划完毕之后，就可以和代码开发一起，进入测试开发的环节，在开发的过程中，一定会发现之前没有考虑到的情况，或者发现效率更高的方法，这时及时调整策略，优化方案。 测试平台与工具测试平台和工具包含测试工具相关的东西，通过优秀工具的使用和研发，让测试开发能够非常简单的进行，找到测试开发的乐趣。 测试数据管理平台测试数据是进行高效测试的基础，尤其是对于我们这种 toB 复杂业务逻辑来说，如果没有良好基础测试数据的支持，我们将花费大量时间在测试数据的准备上，测试的编写和维护将会变成一件很难受的工作。 为了解决这个问题，我们引入测试数据管理平台，他能够帮助我们管理各种测试数据，需要的时候，通过很简单的方式就可能调用这些测试数据，减少人工构造的成本。 这之中的测试数据将主要用到以下四个地方： 后端功能测试 前端 E2E 测试 demo 系统 开发环境 对这个平台而言，它将提供如下功能： 测试数据存储与管理 测试数据的写入与生成 多套后端服务的配置管理，同一个平台，可以向多个后端写入数据？ 通过对外 API，能够通过 API 执行指定的命令 依据 client 请求执行单个批量数据请求写入操作 目前这个平台主要提供一套相对固定的数据，\b 将来，它应该有能力按需及时生成一部分数据，能够用于对数据之间关系要求不高的场景。 后端测试工具为了改善后端测试的效率，我们已经需要开发一些测试工具，让测试开发更简单，主要包含如下几个部分： 基础测试工具，是对开源工具的改善和封装，比如 UTL https://git.seiue.com/open-source/utl/tree/master 应用层相关工具，比如 https://www.yuque.com/kovru3/gfdy75/ygtibk 这里面说的 与测试数据平台的交互，交互方式是什么？类似 UDS 注册的机制？ Reponse 与 schema 定义的一致性检查 前端测试工具同理，前端差不多，可能包含如下几个部分： 基础测试工具最佳实践，封装 数据 Mock 的机制，什么时候 Mock 测试数据平台通信的方式 测试方法论编写可测试代码为了良好的实施自动化测试，我们对各方实施一定的约束，以便能够高效的开展自动化测试，让自动化测试的效能最大化。 被测主体约束被测试主体（包括但不限于后端服务，前端组件，数据层）都应该提供良好的数据测试支持，这样测试代码才能够很好的与测试主体进行交互，从而高效的完成测试。 比如，后端在进行 API 设计的时候需要考虑到测试的场景，能够通过 API 准备需要的测试数据，也可能需要给测试提供专用的 API。\u001f 前端可能将数据数据操作接口暴露到外部，能够让测试代码直接操作内部方法和数据，以便方便高效的完成自动化测试（见附[1]）。 被测试主体应该同时满足多方面的需求，包括但不限于： 业务需求 测试需求 架构需求 代码约束为了进行良好的单元测试，对我们的代码也提出了更高的要求，我们的代码需要更好的可测试性，具体来说包含如下几个方面： 功能划分清晰，职责分明，函数、类的实现应该高内聚，底耦合，一个方法只做一件事 外部依赖显式化，依赖的东西应该单独测试 附[2] 尽量避免副作用，输入输出应该简单统一 More needed 数据与行为分离在测试中，有很多时候我们需要对同一个场景使用不同的数据进行测试，同时期望获取不同的结果，这时如果测试数据和测试代码耦合在一起，就需要将他们同时复制多份，代码可读性和维护起来都是一个问题。 这时，我们可以采用数据与行为分离的策略，将测试行为抽象出来，然后再用给定的数据跑测试。 在 PHP 项目中，我们可以 PHPUnit 的 DataProvider 实现这样的策略，在前端的 Jest 中，也可以使用 jest.each 达成同样的效果。不同测试框架都应该有类似的支持（hmmm, Cypress 好像没有原生的支持）。 App Actions在 E2E 测试中，传统的做法是封装 PageObject，用来封装 UI 层的操作，以便让测试代码更加易于维护，但因为 UI 层的变化一般比较大，这一层的封装成本比较高，而且所有地方都通过 UI 来操作效率很低，稳定性也不好。 所以，Cypress 采用了另外的思路，就是直接在测试代码中操作应用的内部逻辑，我们把这种方式称作 App Actions。某种程度上去掉了和简化了 PageObject 这个封装，从而减少的响应的成本。 它的缺点是需要理解应用的内部状态，但因为我们是开发者自己写测试，所以这个反而变成了优点。 读者具体可以查看 Stop using Page Objects and Start using App Actions 了解更详细的内容。 实施计划测试数据平台[ ] 测试平台准备工作（P0）[ ] 方案优化空间[ ] 环境初始化[ ] 对外提供 API (P1) 测试数据[ ] 用户数据 (P0)[ ] What’s else? 测试工具[ ] 后端测试工具整理和规范 UTL[ ] 后端针对 Event 和 Job 的测试工具[ ] 后端 response 与 schema 的一致性检查 (P0)[ ] 后端与测试平台的交互机制？(P0)[ ] 前端测试工具的实践[ ] 前端与测试平台的交互机制 (P0)[ ] 前端 Mock 的场景与机制 测试流程方法论[ ] 形成最佳实践（跟随实践不断迭代） 附录[1] https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/[2] http://www.voidcn.com/article/p-uyjitnuy-bno.html","tags":["测试"]},{"title":"JS 垃圾回收机制","path":"/2023/01/15/garbage-recycling-mechanism/","content":"一、垃圾回收机制——GCJavascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 通常情况下有两种实现方式： 标记清除js 中最常用的垃圾回收方式就是标记清除。 当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 引用计数跟踪记录每个值被引用的次数 当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。 二、内存管理 Javascript 引擎基础 GC 方案是 （simple GC）：mark and sweep（标记清除），即： 1）遍历所有可访问的对象； 2）回收已不可访问的对象。 GC 的缺陷 和其他语言一样，JavaScript 的 GC 策略也无法避免一个问题：GC 时，停止响应其他操作，这是为了安全考虑。而 Javascript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免 GC 造成的长时间停止响应。 GC 优化策略 1）分代回收（Generation GC） 这个和 Java 回收策略思想是一致的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次 GC 的耗时。 2）增量 GC 这个方案的思想很简单，就是“每次处理一点，下次再处理一点”，如此类推。","tags":["JS"]},{"title":"实现图片的懒加载","path":"/2022/12/14/img-lazyload/","content":"图片的懒加载原理： 当图片元素出现在屏幕中时，才给图片的 src 赋值对应的链接，去加载对应的图片 scrollTop 和 img.offsetTop 判断 图片加载条件： img.offsetTop window.innerHeight + document.body.scrollTop div class=container img src=loading.gif data-src=pic.png / img src=loading.gif data-src=pic.png / img src=loading.gif data-src=pic.png / img src=loading.gif data-src=pic.png / img src=loading.gif data-src=pic.png / img src=loading.gif data-src=pic.png //divscript let imgs = document.querySelectAll(img); function lazyLoad() const scrollTop = document.body.scrollTop || document.documentElement.scrollTop; const winHeight = window.innerHeight; for (let i = 0; i imgs.length; i++) if (imgs[i].offsetTop scrollTop + winHeight) imgs[i].src = imgs[i].getAttribute(data-src); window.onscroll = lazyLoad(); /script IntersectionObserver使用 IntersectionObserver 监听元素来判断是否出现在视口，当图片出现在视口时，给 img.src 赋值 IntersectionObserver 替代监听 scroll 事件来判断元素是否在视口中，性能更高 图片懒加载示例 // html内容// img src=./loading.jpg src=https://cube.elemecdn.com/6/94/4d3ea53c084bad6931a56d5158a48jpeg.jpeg// img src=./loading.jpg src=https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpegfunction observerImg() let imgList = document.getElementsByTagName(img); let observer = new IntersectionObserver((list) = list.forEach((item) = // 判断元素是否出现在视口 if (item.intersectionRatio 0) item.target.src = item.target.getAttribute(src); observer.unobserve(item.target); ); ); for (let i = 0; i imgList.length; i++) // 监听每个img元素 observer.observe(imgList[i]);","tags":["性能优化"],"categories":["性能优化"]},{"title":"git","path":"/2022/11/18/git/","content":"merge vs rebase在 Git 中，Merge 和 Rebase 是两种常见的分支合并策略，它们分别用于将一个分支的更改合并到另一个分支上，但它们的工作方式和影响略有不同。 Merge（合并）Merge 操作将两个分支的历史合并为一个新的合并提交。这个合并提交有两个父提交，分别代表了合并前的两个分支。Merge 操作会保留原始分支的历史记录，因此在分支图中会形成一个新的合并节点。 特点 保留分支历史：Merge 操作会保留原始分支的完整历史记录，包括合并提交。这使得分支的历史记录更加清晰可见。 生成合并提交：Merge 操作会生成一个新的合并提交，该提交包含了合并前的两个分支的更改。 保留分支结构：Merge 操作会保留分支的结构，不会改变提交的顺序或线性性。 Rebase（变基）Rebase 操作是将当前分支的提交重新应用到另一个分支上。它会将当前分支的提交逐个应用到目标分支的最新提交上，并在此过程中解决可能出现的冲突。Rebase 操作会改变提交的顺序和历史，使得合并后的提交历史更加线性化。 特点 线性化提交历史：Rebase 操作会将当前分支的提交逐个应用到目标分支的最新提交上，从而使得提交历史更加线性化。 不产生合并提交：与 Merge 不同，Rebase 不会生成新的合并提交，而是将当前分支的提交直接放置在目标分支的顶部。 改变提交的哈希值：由于 Rebase 改变了提交的历史，因此会改变提交的哈希值。因此，不建议对已发布的提交进行 Rebase 操作。 总结Merge 适用于合并两个独立开发的分支，而 Rebase 则适用于保持提交历史的线性化。 revert vs resetrevertgit revert 命令用于撤销之前的提交，但是通过创建一个新的提交来实现。新的提交包含了撤销了原来提交的更改。使用 revert 命令可以在撤销提交的同时保留提交历史，不会改变历史记录。 resetgit reset 命令用于将 HEAD 指针移动到另一个提交，并且可以选择保留或丢弃修改。reset 命令有三种模式：--soft、--mixed 和 --hard。 --soft 模式：仅移动 HEAD 指针，不会修改暂存区和工作目录的内容。 --mixed 模式（默认模式）：移动 HEAD 指针，并且重置暂存区，但是不会修改工作目录的内容。 --hard 模式：移动 HEAD 指针，并且重置暂存区和工作目录的内容，将其回退到指定提交的状态。 git reset --soft commitgit reset --mixed commitgit reset --hard commit","tags":["git"]},{"title":"三次握手和四次挥手","path":"/2022/09/19/tree-way-handshake/","content":"三次握手（Three-Way Handshake）和四次挥手（Four-Way Handshake）是 TCP（Transmission Control Protocol，传输控制协议）连接建立和断开的过程。 三次握手：第一步（SYN）：客户端向服务器发送一个 SYN（同步）包，表示客户端请求建立连接，并选择一个初始序列号（Sequence Number）。 第二步（SYN-ACK）：服务器接收到 SYN 包后，会发送一个 SYN-ACK 包作为响应。该包中包含了确认号（Acknowledgment Number），其值为客户端发送的序列号+1，同时服务器也选择一个初始序列号。 第三步（ACK）：客户端接收到服务器发送的 SYN-ACK 包后，会发送一个 ACK（确认）包作为确认。该 ACK 包中的确认号为服务器发送的序列号+1，表示客户端已经接收到了服务器的确认。这样，通过这三次握手，TCP 连接就建立起来了，双方都可以开始进行数据传输。 四次挥手：第一步（FIN）：当客户端想要关闭连接时，会向服务器发送一个 FIN（结束）包，表示客户端不再发送数据。 第二步（ACK）：服务器接收到客户端发送的 FIN 包后，会发送一个 ACK 包作为确认。但是，服务器可能还有未发送完的数据，因此服务器此时不会立即关闭连接。 第三步（FIN）：当服务器完成发送所有数据后，会向客户端发送一个 FIN 包，表示服务器已经准备好关闭连接了。 第四步（ACK）：客户端接收到服务器发送的 FIN 包后，会发送一个 ACK 包作为确认。然后，客户端等待一段时间（TIME_WAIT 状态），以确保服务器已经接收到了最后的 ACK 包，然后关闭连接。这样，通过这四次挥手，TCP 连接就彻底关闭了。 总的来说，三次握手是建立 TCP 连接的过程，而四次挥手则是断开 TCP 连接的过程。这些过程确保了数据的可靠传输和连接的正常终止。","tags":["http"]},{"title":"回流和重绘","path":"/2022/08/25/reflow-repaint/","content":"回流必将引起重绘，重绘不一定会引起回流。 回流当 渲染树 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 页面首次渲染 浏览器窗口大小变化 元素内容、尺寸、位置、字体大小变化 激活 css 伪类 查询某些属性或调用某些方法 添加或删除可见的 DOM 元素 重绘当页面的某些元素的样式发生变化，不会影响在文档流中的位置时，浏览器会对元素进行重新绘制。 color、 background 相关属性： background-color、 background-image… outline 相关属性 visibility 、border-radius 、box-shadow 如何避免回流和重绘？ 操作 DOM 时，尽量在低层次的 DOM 节点进行操作 不要使用 table 布局，一个小的改动可能会使整个 table 进行重新布局 使用 css 的表达式 不要频繁操作元素的样式， 可以先将元素设为display:none,然后再显示出来。 元素的多个操作批处理 使用absolute或 fixed 使元素脱离文档流，这样子他们发生变化不会影响其他元素。","tags":["CSS"]},{"title":"原型和原型链","path":"/2022/03/18/prototype/","content":"原型原型： 每个函数都有 prototype 属性，称之为原型因为这个属性的值是一个对象，称为 原型对象(Array.prototype) 作用 存放一些属性和方法 在 JS 中实现继承 const arr = new Array(1, 2, 3);arr.reverse();arr.__proto__ === Array.prototype; __proto__:每个对象都有__proto__属性作用： 这个属性指向它的原型对象 原型链对象都有__proto__属性，这个属性指向它的 person—__proto__—person.prototype—__proto__—Object.prototype—__proto__—null","tags":["JS"]},{"title":"React 组件的编写","path":"/2022/03/08/react-components/","content":"在编写 React 组件时，有一些最佳实践需要遵循： 单一职责就像函数一样，组件也应当遵循单一职责的原则，即每个组件只能负责一个功能。请阅读官方示例中的第一步。 将一个功能复杂的大组件拆分为多个职责单一的小组件可以获得以下好处： 可读性和可维护性的提升：小组件代码更短，且服务于同一目的；读者可以按层级理解代码。 可测试性的提升：小组件更容易做单元测试。 可复用性的提升：小组件可以在简单的调整和提取后被复用于其他场景。 性能的提升：state 的变化不再总是触发整个大组件的重渲染。 文件结构拆分组件时在文件结构上的最佳实践是，假设原来有一个大组件是 Complex.tsx，拆分后它应变成一个文件夹： - Complex - index.tsx // 简化后的大组件 - SubA.tsx // 拆分出来的小组件 - SubB.tsx // 拆分出来的小组件 State 最小集渲染组件所需要的数据有以下来源：外部传入的 prop、组件内部的 state、全局 state（比如 redux store）、组件 scope 外的常量，以及由前面这些基础数据计算得到的间接数据（即 Vue 中的 computed）。 新人易犯的错误是将间接数据作为 state 来维护，然后用 useEffect 去监听其他 stateprop 并重新计算该数据。 组件内部 state 应是一个最小集，不包含任何间接数据或常量。请阅读官方示例中的第三步。 Prop 的设计Prop 的设计应尽量从组件本身的需求出发，而不是套用父组件已有的数据和方法。举例来说： 如果子组件需要的数据 c 是由父组件中的 a 和 b 计算而来的，那么应该为 c 设计一个 prop，在父组件中用 a 和 b 计算出 c 之后传给子组件，而不是为 a 和 b 设计两个 prop，在子组件内部再计算 c。这一条原则也可以理解为 prop 最小集。 如果子组件需要反向传递数据去设置父组件的 state（假设要传递的数据是 date），不要设计一个 setDate prop 然后把父组件的 setDate 直接传给子组件，而是设计一个 onDateChange prop，允许父组件设置一个 callback 去监听子组件的 date 变化。子组件不关心父组件是要 setDate 还是做什么，子组件只负责“广播”自己的数据变化“事件”。 组件内的代码组织目前我们统一用 React hooks 编写组件，hooks 的一大优势就是允许我们将组件内的代码按业务逻辑而非性质分组： const Bad = () = // states const [state1, setState1] = useState(0); const [state2, setState2] = useState(true); // computed const computed1 = state1 + 1; const computed2 = !state2; const computed3 = `$computed1 $computed2`; // side effects useEffect(() = sideEffect1(); sideEffect2(); , []);;const Good = () = // logic group 1 const [state1, setState1] = useState(0); const computed1 = state1 + 1; useEffect(() = sideEffect1(); , []); // logic group 2 const [state2, setState2] = useState(true); const computed2 = !state2; useEffect(() = sideEffect2(); , []); // logic group 3 const computed3 = `$computed1 $computed2`;; 如果组件中有很多个逻辑分组，可能就是该组件需要进一步拆分的信号。 Context当一个组件树中有很多不同层级的组件需要访问一批同样的数据时，完全用 prop 传递会导致中间层的组件为了往下传递而多出很多它自己并不关心的 prop，此时你通常需要 context 解决方案，请阅读官方文档。 当需要层层传递的数据本身非常简单时，也有除了 context 之外的解决方案。 表现与逻辑的分离组件主要负责表现层（即 UI 层）的逻辑，因此复杂的数据处理逻辑原则上不属于组件的职责，应提取为工具函数而不是直接放一大段代码在组件内。这个职责分离的原则与上文组件拆分的原则在本质上是一致的，即每个单元应负责自己唯一的职责。","tags":["React"]},{"title":"Cookie、sessionStorage、localStorage 的区别","path":"/2022/02/19/cookie-storage/","content":"cookie、sessionStorage 和 localStorage 都是在 Web 浏览器中用于存储数据的机制，但它们之间有一些重要的区别。 1. cookie：cookie 是由服务器发送到客户端并存储在客户端的文本文件，每次客户端向同一服务器发送请求时都会附上这些 cookie。主要用于跟踪用户的会话状态、记录用户的偏好设置等。 Cookie 的特点包括： 存储容量较小（每个 Cookie 通常限制在 4KB 左右）。 每次 HTTP 请求都会发送到服务器，包括 Cookie 信息，因此可能会影响性能。 可以设置 Cookie 的过期时间，使得 Cookie 在一定时间后失效。 2. sessionStorage：sessionStorage 是 HTML5 引入的新特性，用于在客户端临时存储会话数据，该数据在当前会话期间有效，关闭标签页或浏览器时会被清除。 sessionStorage 的特点包括： 数据仅在当前会话期间有效，关闭标签页或浏览器时会被清除。 存储容量较大，通常比 Cookie 大得多（通常限制在 5MB 左右）。 数据仅在同一标签页或同一窗口中共享，不同标签页或窗口间不共享。 3. localStorage：localStorage 也是 HTML5 引入的新特性，与 sessionStorage 相似，用于在客户端存储数据。不同的是，localStorage 中存储的数据在关闭标签页或浏览器后仍然保留，直到被用户手动清除。 localStorage 的特点包括： 存储容量较大，通常比 Cookie 大得多（通常限制在 5MB 左右）。 数据在浏览器关闭后仍然保留，直到被用户手动清除。 数据在同一域名下的所有标签页和窗口中共享。 综上所述，Cookie 主要用于在客户端和服务器之间传递会话信息，而 sessionStorage 和 localStorage 用于在客户端存储临时数据。其中，sessionStorage 的数据在当前会话期间有效，而 localStorage 的数据则持久保存在客户端，直到被用户清除。localStorage 和 sessionStorage 的存储容量通常比 Cookie 大得多，并且可以更高效地使用。","tags":["JS","浏览器","http"]},{"title":"ssl","path":"/2022/02/19/ssl/","content":"SSL（Secure Sockets Layer，安全套接层）是一种用于保护网络通信安全的协议。SSL 最初由网景公司（Netscape）开发，后来发展为 TLS（Transport Layer Security，传输层安全），TLS 取代了 SSL 成为更安全和更先进的协议。然而，人们通常仍然使用术语 SSL 来指代 TLS。 SSLTLS 协议提供了以下主要功能： 加密（Encryption）：SSLTLS 使用加密技术对数据进行加密，从而确保在网络上传输的数据在传输过程中不会被未经授权的人员窃听或窃取。常用的加密算法包括对称加密（如 AES）和非对称加密（如 RSA）。 身份认证（Authentication）：SSLTLS 协议使用数字证书来验证通信双方的身份。数字证书由可信的第三方机构（CA，Certificate Authority）颁发，用于证明通信实体的身份。这样，通信双方可以确保他们正在与预期的对方进行通信，而不是中间人（Man-in-the-Middle）攻击。 数据完整性（Data Integrity）：SSLTLS 使用哈希函数和消息认证码（MAC，Message Authentication Code）来保证数据在传输过程中不会被篡改。这确保了数据在传输过程中的完整性，即接收方能够检测到任何数据被篡改的情况。 SSLTLS 协议的工作流程大致如下： 握手阶段：客户端发送一个连接请求给服务器，服务器在确认客户端的身份后，发送数字证书给客户端。客户端验证数字证书，然后生成一个随机密钥，用服务器的公钥加密后发送给服务器。接着，服务器使用私钥解密随机密钥。这样，双方就拥有了共享的密钥，用于后续的加密和解密操作。 加密通信：双方使用共享密钥进行加密和解密操作，确保了数据在传输过程中的安全性。 断开连接：通信结束后，双方发送关闭连接的通知，然后安全地关闭连接。 SSLTLS 协议被广泛应用于 Web 浏览器和服务器之间的安全通信，以及其他需要保护通信安全性的场景，如电子邮件传输、文件传输等。","tags":["http"]},{"title":"设计模式","path":"/2021/10/14/design-patterns/","content":"设计模式是从许多优秀的软件系统中，总结出的成功的、能够实现可维护性、复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作。 单例模式(弹框)一个类只能构造出唯一实例 class Single constructor(name) this.name = name; static getInstance(name) // 静态方法 if (!this.instance) // 关键代码 this指向的是Single这个构造函数 this.instance = new Single(name); return this.instance; let single1 = Single.getInstance(name1);let single2 = Single.getInstance(name2);console.log(single1 === single2); // true 策略模式(表单验证)根据不同参数命中不同的策略 策略模式的表单验证示例// 策略对象const strategies = // 验证是否为空 isNoEmpty: function(value, errorMsg) if (value.trim() === ) return errorMsg; , // 验证最小长度 minLength: function(value, length, errorMsg) if (value.trim().length length) return errorMsg; , // 验证最大长度 maxLength: function(value, length, errorMsg) if (value.length length) return errorMsg; , // 验证手机号 isMobile: function(value, errorMsg) if ( !/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\\d8$/.test( value ) ) return errorMsg; ;// 验证类class Validator constructor() this.cache = []; // 存储要验证的方法 this.errList = []; // 存储最终的验证结果 add(value, rules) for (let i = 0, rule; (rule = rules[i++]); ) let strategyAry = rule.strategy.split(:); let errorMsg = rule.errorMsg; this.cache.push(() = let strategy = strategyAry.shift(); strategyAry.unshift(value); strategyAry.push(errorMsg); // 执行策略对象中的不同验证规则 let error = strategies[strategy](...strategyAry strategy); if (error) this.errList.push(error); ); start() for (let i = 0, validatorFunc; (validatorFunc = this.cache[i++]); ) validatorFunc(); return this.errList; let validataFunc = function(info) let validator = new Validator(); validator.add(info.userName, [ strategy: isNoEmpty, errorMsg: 用户名不可为空 , strategy: minLength:2, errorMsg: 用户名长度不能小于2位 ]); validator.add(info.password, [ strategy: minLength:6, errorMsg: 密码长度不能小于6位 ]); validator.add(info.phoneNumber, [ strategy: isMobile, errorMsg: 请输入正确的手机号码格式 ]); return validator.start();;// 需要验证表单的对象let userInfo = userName: 王, password: 1234, phoneNumber: 666;let errorMsg = validataFunc(userInfo);console.log(errorMsg); // [用户名长度不能小于2位, 密码长度不能小于6位, 请输入正确的手机号码格式] 代理模式(图片预加载)代理对象和本体对象具有一致的接口 图片代理模式示例// 代理模式let relImage = (function () let imgNode = document.createElement(img); document.body.appendChild(imgNode); return setSrc(src) imgNode.src = src; , ;)();let proxyImage = (function () let img = new Image(); // 实际要加载的图片 加载成功后 替换调占位图 img.onload = function () relImage.setSrc(img.src); ; return setSrc(src) img.src = src; // 设置占位图 relImage.setSrc( https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg ); , ;)();// 设置实际要加载的图片proxyImage.setSrc( https://cube.elemecdn.com/6/94/4d3ea53c084bad6931a56d5158a48jpeg.jpeg); 装饰者模式(在函数执行前后添加新的方法)在不改变对象自身的基础上，动态地给某个对象添加一些额外的职责 装饰者模式示例function fuc() console.log(2);Function.prototype.before = function (beFn) let self = this; return function () beFn.apply(this, arguments); // 先执行插入到前面的方法，类似于二叉树的前序遍历 return self.apply(this, arguments); // 后执行当前的方法 ;;Function.prototype.after = function (afFn) let self = this; return function () self.apply(this, arguments); // 先执行当前的方法 return afFn.apply(this, arguments); // 后执行插入到后面的方法 ;;function fuc1() console.log(1);function fuc3() console.log(3);function fuc4() console.log(4);fuc = fuc.before(fuc1).before(fuc4).after(fuc3);fuc();// 最终打印结果：4 1 2 3 组合模式(打印文件目录)组合模式在对象间形成树形结构组合模式中基本对象和组合对象被一致对待无须关心对象有多少层, 调用时只需在根部进行调用 函数组合模式示例class Combine constructor() this.list = []; add(fn) this.list.push(fn); return this; // 链式调用 excute() for (let i = 0; i this.list.length; i++) this.list[i].excute(); let comb1 = new Combine();comb1 .add( excute() console.log(1); , ) .add( excute() console.log(2); , );let comb2 = new Combine();comb2 .add( excute() console.log(3); , ) .add( excute() console.log(4); , );let comb3 = new Combine();comb3 .add( excute() console.log(5); , ) .add( excute() console.log(6); , );comb2.add(comb3);let comb4 = new Combine();comb4.add(comb1).add(comb2);comb4.excute();// 最终打印结果：1 2 3 4 5 6 工厂模式(jquery 中的 window.$)工厂模式是用来创建对象的一种最常用的设计模式 不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，这个函数就可以被视为一个工厂 工厂模式示例class Car constructor(name, color) this.name = name; this.color = color; class Factory static create(type) switch (type) case car: return new Car(汽车, 白色); break; case bicycle: return new Car(自行车, 黑色); break; default: console.log(没有该类型); let p1 = Factory.create(car);let p2 = Factory.create(bicycle);console.log(p1, p1 instanceof Car); // name: 汽车, color: 白色 trueconsole.log(p2, p2 instanceof Car); // name: 自行车, color: 黑色 true 访问者模式(babel 插件)在不改变该对象的前提下访问其结构中元素的新方法 访问者模式示例// 元素类class Student constructor(name, chinese, math, english) this.name = name; this.chinese = chinese; this.math = math; this.english = english; accept(visitor) visitor.visit(this); // 访问者类class ChineseTeacher visit(student) console.log(`语文 $student.chinese`); class MathTeacher visit(student) console.log(`数学 $student.math`); class EnglishTeacher visit(student) console.log(`英语 $student.english`); // 实例化元素类const student = new Student(张三, 90, 80, 60);// 实例化访问者类const chineseTeacher = new ChineseTeacher();const mathTeacher = new MathTeacher();const englishTeacher = new EnglishTeacher();// 接受访问student.accept(chineseTeacher); // 语文90student.accept(mathTeacher); // 数学80student.accept(englishTeacher); // 英语60 发布订阅模式(EventBus)订阅者订阅相关主题，发布者通过发布主题事件的方式，通知订阅该主题的对象 手写发布订阅模式示例// 发布订阅模式class EventBus constructor() this.task = ; on(type, fn) // on 注册事件 if (!this.task[type]) this.task[type] = []; this.task[type].push(fn); emit(type, ...args) // emit 发送事件 if (this.task[type]) this.task[type].forEach((fn) = fn.apply(this, args); // 注意this指向 ); off(type, fn) // 删除事件 if (this.task[type]) this.task[type] = this.task[type].filter((item) = item !== fn); once(type, fn) // 只执行一次 function f(...args) fn(...args); this.off(type, f); this.on(type, f); // 测试let event = new EventBus();event.on(change, (...args) = console.log(args););// 只执行一次event.once(change, (...args) = console.log(args););event.emit(change, 1, 2);event.emit(change, 2, 3); 观察者模式(vue 双向绑定)一个对象有一系列依赖于它的观察者（watcher），当对象发生变化时，会通知观察者进行更新 观察者模式示例let data = name: ming, age: 18,;Object.keys(data).forEach((key) = let value = data[key]; Object.defineProperty(data, key, get() console.log(get, value); return value; , set(newValue) console.log(更新); value = newValue; , ););data.name = 佩奇;console.log(data.name);// 依次打印： 更新 → get 佩奇 → 佩奇 观察者与发布订阅模式的区别观察者模式：一个对象有一系列依赖于它的观察者（watcher），当对象发生变化时，会通知观察者进行更新 发布订阅模式：订阅者订阅相关主题，发布者通过发布主题事件的方式通知订阅该主题的对象，发布订阅模式中可以基于不同的主题去执行不同的自定义事件","tags":["JS"]},{"title":"xss攻击","path":"/2021/01/19/xss/","content":"XSS（Cross-Site Scripting，跨站脚本攻击）是一种常见的 Web 安全漏洞，攻击者利用这种漏洞向网页中插入恶意脚本，从而在用户的浏览器中执行恶意代码。XSS 攻击通常分为三种类型： 1. 存储型 XSS：存储型 XSS 攻击，也称为持久型 XSS 攻击，是攻击者将恶意脚本存储在服务器端的数据库中。当用户访问包含恶意脚本的页面时，这些脚本从服务器端获取并执行，从而对用户进行攻击。 2. 反射型 XSS：反射型 XSS 攻击，也称为非持久型 XSS 攻击，是攻击者将恶意脚本作为 URL 参数发送给受害者。当受害者点击包含恶意脚本的链接时，这些脚本会反射到受害者的浏览器中执行，从而对用户进行攻击。 3. DOM 型 XSS：DOM 型 XSS 攻击是攻击者利用客户端的漏洞，通过修改页面的 DOM 结构来执行恶意脚本。与存储型和反射型 XSS 不同，DOM 型 XSS 攻击不会将恶意脚本发送到服务器端，而是直接操作客户端的 DOM 来实现攻击。 为了防止 XSS 攻击，可以采取以下措施 ： 1.输入验证：对所有用户输入的数据进行验证和过滤，防止恶意脚本的注入。可以使用白名单机制来限制输入数据的类型和格式，过滤掉所有不合法的输入。 2.输出编码：在将用户输入的数据输出到页面时，使用适当的编码方式对数据进行转义，防止恶意脚本的执行。常用的编码方式包括 HTML 实体编码、JavaScript 转义编码等。 3.设置 HTTP 头部：使用X-Content-Type-Options 头部来防止浏览器的 MIME 类型猜测行为，使用 Content-Security-Policy 头部来限制页面加载的资源来源，防止恶意脚本的执行。 4.Cookie 安全：设置 HTTPOnly 属性来限制 Cookie 只能通过 HTTP 协议传输，防止 JavaScript 脚本获取 Cookie 信息，从而减少受到 XSS 攻击的可能性。 5. 安全的开发实践：开发人员应当采用安全的编码实践，如避免使用 eval 函数、使用 CSP（Content Security Policy）等来限制页面加载的资源来源。 通过以上措施，可以有效地减少 XSS 攻击的风险，并提升 Web 应用程序的安全性","tags":["http"]},{"title":"sleep 函数","path":"/2020/12/18/sleep-function/","content":"JS 没有语言内置的休眠（sleep or wait）函数，所谓的 sleep 只是实现一种延迟执行的效果 等待指定时间后再执行对应方法 方法一：伪死循环阻塞主线程// 因为JS是单线程的，所以通过这种方式可以实现真正意义上的sleepfunction sleep1(fn, time) let start = new Date().getTime(); while (new Date().getTime() - start time) continue; fn(); 方式二： 定时器function sleep2(fn, time) setTimeout(fn, time); 方式三：promisefunction sleep3(fn, time) new Promise(resolve = setTimeout(resolve, time); ).then(() = fn(); ); 方式四：async awaitasync function sleep4(fn, time) await new Promise((resolve) = setTimeout(resolve, time); ); fn();function fn() console.log(fn);sleep1(fn, 2000);sleep2(fn, 2000);sleep3(fn, 2000);sleep4(fn, 2000);","tags":["JS"]},{"title":"JSBridge","path":"/2020/07/21/JSBridge/","content":"随着移动端盛行，不管是混合开发（Hybrid）应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。 JSBridge 的作用通过 JSBridge 可以实现 H5 和 原生之间的双向通信，主要是给 H5 提供调用 原生（Native）功能的接口，让混合开发中的 H5 可以方便地使用地址位置、摄像头甚至支付等原生功能。 JSBridge 的通信原理主要有两种：注入 API 和 拦截 URL SCHEME。 注入 API注入 API 方式是最常用的方式，主要原理是通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。 注入 API 时，H5 端的代码1）初始化 WebViewJavascriptBridge// 根据navigator.userAgent来判断当前是 Android 还是 iosconst u = navigator.userAgent;// Android终端const isAndroid = u.indexOf(Android) -1 || u.indexOf(Adr) -1;// IOS 终端const isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);/** * 配合 IOS 使用时的初始化方法 */const iosFunction = (callback) = if (window.WebViewJavascriptBridge) return callback(window.WebViewJavascriptBridge); if (window.WVJBCallbacks) return window.WVJBCallbacks.push(callback); window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement(iframe); WVJBIframe.style.display = none; WVJBIframe.src = demo://__BRIDGE_LOADED__; document.documentElement.appendChild(WVJBIframe); setTimeout(function () document.documentElement.removeChild(WVJBIframe); , 0);;/** * 配合 Android 使用时的初始化方法 */const androidFunction = (callback) = if (window.WebViewJavascriptBridge) callback(window.WebViewJavascriptBridge); else document.addEventListener( WebViewJavascriptBridgeReady, function () callback(window.WebViewJavascriptBridge); , false ); ;window.setupWebViewJavascriptBridge = isAndroid ? androidFunction : iosFunction;isAndroid window.setupWebViewJavascriptBridge(function (bridge) // 注册 H5 界面的默认接收函数 bridge.init(function (msg, responseCallback) responseCallback(JS 返回给原生的消息内容); ); ); 2）注册与原生交互的事件函数// bridge.registerHandler(事件函数名,fun 执行函数);window.setupWebViewJavascriptBridge((bridge) = // data：原生传过来的数据; // callback: 原生传过来的回调函数 bridge.registerHandler(H5Function, (data, callback) = callback callback(); );); 3）调用原生注册的事件函数// bridge.callHandler(安卓端函数名, 传给原生端的数据, callback 回调函数);window.setupWebViewJavascriptBridge((bridge) = bridge.callHandler(changeData, data, (result) = console.log(result); );); 拦截 URL SCHEME先解释一下 URL SCHEME：URL SCHEME 是一种类似于 url 的链接，是为了方便 app 直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的 例如打开微信扫码的 SCHEME：weixin:scanqrcodeprotocol 是 weixin，host 则是 scanqrcode 拦截 URL SCHEME 的主要流程Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求，并根据 URL SCHEME（包括所带的参数）进行相关操作（类似JSONP的方式） URL SCHEME 的缺陷1）使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患2）创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长","tags":["JS"]},{"title":"强缓存和协商缓存","path":"/2020/02/20/strong-cache/","content":"强缓存所谓强缓存，可以理解为强制缓存的意思，即浏览器在访问某个资源时会判断是否使用本地缓存里已经存在的资源文件，使用本地缓存的话则不会发送请求到服务器，从而达到减轻服务器访问压力的作用，且由于直接从本地缓存读取资源文件，大大提高了加载速度。 强缓存的具体流程为：浏览器第一次请求远程服务器的某个资源时，如果服务器希望浏览器得到该资源后一段时间内不要再发送请求过来，直接从浏览器里的缓存里取，则服务器可以通过在响应头里设置 Cache-Control: max-age=31536000，max-age 代表缓存时间，单位为秒，这里的数据换算过来就是一年，意味着在一年内浏览器不会再向服务器发送请求。 使用缓存的话，状态码 200 后面会标明情况。浏览器缓存资源的地方有两个：磁盘缓存（disk cache）和内存缓存（memory cache）。 Cache-Control 除了 max-age 外，还可以设置其它属性值： no-cache: 不使用强缓存（但仍会使用协商缓存）。 no-store: 不使用缓存（不使用强缓存也不使用协商缓存），每次都向服务器发送资源请求。 private： 只允许客户端使用缓存，不允许其他代理服务器进行缓存。 public: 客户端和代理服务器都可缓存。 s-maxage: 与 max-age 类似，区别是 s-maxage 是设定代理服务器的缓存时间。 强缓存除了使用Cache-Control实现之外，还可以使用Expires字段，Expires是 Http1.0 规范，Cache-Control是 Http1.1 规范，Expires返回一个具体的时间值（如下图所示），代表缓存的有效期，在该日期内浏览器不会向服务器发起请求，而是直接从缓存里获取资源。 因为 Expires 参照的是本地客户端的时间，而客户端的时间是可以被修改的，所以会有误差产生的情况，这也是 Expires 的一个缺点，所以有了后来 Http1.1 规范的 Cache-control。另外，Cache-control 的优先级要高于 Expires，如果两者同时设置，会优先使用 Cache-control 而忽略掉 Expires。 协商缓存在强缓存里，是否使用缓存是由浏览器来确定的，而协商缓存则是由服务器来告诉浏览器是否使用缓存资源，也就是浏览器每一次都要发送请求到服务器询问是否使用缓存，协商缓存的具体流程如下： 浏览器初次请求资源，服务器返回资源，同时生成一个Etag值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带If-None-Match，值是之前服务器返回的Etag的值，服务器收到之后拿该值与资源文件最新的Etag值做对比。 如果没有变化则返回 304，告诉浏览器继续使用缓存（不返回资源文件）。 如果发生变化，则返回 200 和最新的资源文件给浏览器使用。 除了 Etag 外，还有一个 Last-Modified 的属性，它是 Http1.0 规范的，服务器返回 Last-Modified，浏览器请求头对应携带的是 If-Modified-since，与 Etag 不同的是，Last-Modified 的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存。 相比 Last-Modified，Etag 优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，Last-Modified 不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的。 总结强缓存就是浏览器本地根据服务器设置的过期时间来判断是否使用缓存，未过期则从本地缓存里拿资源，已过期则重新请求服务器获取最新资源。 协商缓存则是浏览器本地每次都向服务器发起请求，由服务器来告诉浏览器是从缓存里拿资源还是返回最新资源给浏览器使用。 参考链接","tags":["http"]},{"title":"todo","path":"/2019/12/18/todo/","content":"图片标注immerimmutablegraphqlnodenavigator.online(rel) npm package 包和模块的区别 如何避免业务项目被发布到 npm monorepoElectronJS Hybrid webpack、babel、postcss 等 taiwind react 18 bff 层"},{"title":"JS 数组方法","path":"/2019/11/10/array-function/","content":"改变原数组的方法(9 个)1.splice() 添加 删除数组元素splice() 方法向从数组中添加删除项目，然后返回被删除的项目 array.splice(index,howmany,item1,.....,itemX) index：必需。整数，规定添加删除项目的位置，使用负数可从数组结尾处规定位置。howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。item1, …, itemX： 可选。向数组添加的新项目。返回值: 如果有元素被删除,返回包含被删除项目的新数组。 删除元素// 从数组下标0开始，删除3个元素let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3); // [1,2,3]console.log(a); // [4,5,6,7]// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7let item = a.splice(-1, 3); // [7] 删除并添加// 从数组下标0开始，删除3个元素，并添加元素添加let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3, 添加); // [1,2,3]console.log(a); // [添加,4,5,6,7]// 从数组最后第二个元素开始，删除3个元素，并添加两个元素添加1、添加2let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-2, 3, 添加1, 添加2); // [6,7]console.log(b); // [1,2,3,4,5,添加1,添加2] 不删除只添加let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 0, 添加1, 添加2); // [] 没有删除元素，返回空数组console.log(a); // [添加1,添加2,1,2,3,4,5,6,7]let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-1, 0, 添加1, 添加2); // [] 没有删除元素，返回空数组console.log(b); // [1,2,3,4,5,6,添加1,添加2,7] 在最后一个元素的前面添加两个元素 2.sort() 数组排序sort() 方法对数组元素进行排序，并返回这个数组。 参数可选: 规定排序顺序的比较函数。默认情况下 sort() 方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用 toString() 方法将元素转化为字符串的 Unicode (万国码)位点，然后再比较字符。 不传参// 字符串排列 看起来很正常var a = [Banana, Orange, Apple, Mango];a.sort(); // [Apple,Banana,Mango,Orange]// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的var a = [10, 1, 3, 20, 25, 8];console.log(a.sort()); // [1,10,20,25,3,8]; 比较函数的两个参数：sort 的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素： 若比较函数返回值 0 ，那么 a 将排到 b 的前面; 若比较函数返回值 0 ，那么 a 和 b 相对位置不变； 若比较函数返回值 0 ，那么 b 排在 a 将的前面； 数字升降序var array = [10, 1, 3, 4, 20, 4, 25, 8];array.sort(function (a, b) return a - b;);console.log(array); // [1,3,4,4,8,10,20,25];array.sort(function (a, b) return b - a;);console.log(array); // [25,20,10,8,4,4,3,1]; pop() 删除一个数组中的最后的一个元素定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。 let a = [1, 2, 3];let item = a.pop(); // 3console.log(a); // [1,2] shift() 删除数组的第一个元素定义: shift()方法删除数组的第一个元素，并返回这个元素。 let a = [1, 2, 3];let item = a.shift(); // 1console.log(a); // [2,3] push() 向数组的末尾添加元素定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组末尾的元素 let a = [1, 2, 3];let item = a.push(末尾, 233); // 5console.log(a); // [1,2,3,末尾, 233] unshift()定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组开头的元素 let a = [1, 2, 3];let item = a.unshift(开头, 开头 2); // 5console.log(a); // [ 开头, 开头 2, 1, 2, 3 ] reverse() 颠倒数组中元素的顺序定义: reverse() 方法用于颠倒数组中元素的顺序。 let a = [1, 2, 3];a.reverse();console.log(a); // [3,2,1] 不改变原数组的方法（8 个）slice() 浅拷贝数组的元素定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。 语法：array.slice(begin, end); let a = [hello, world];let b = a.slice(0, 1); // [hello]// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。a[0] = 改变原数组;console.log(a, b); // [改变原数组,world] [hello]let a = [ name: OBKoro1 ];let b = a.slice();console.log(b, a); // [name:OBKoro1] [name:OBKoro1]// a[0].name=改变原数组// console.log(b,a) // [name:改变原数组] [name:改变原数组] join() 数组转字符串定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) let a = [hello, world];let str = a.join(); // hello,worldlet str2 = a.join(+); // hello+worldlet a = [[OBKoro1, 23], test];let str1 = a.join(); // OBKoro1,23,testlet b = [ name: OBKoro1, age: 23 , test];let str2 = b.join(); // [object Object],test// 对象转字符串推荐 JSON.stringify(obj)// 结论：// join()/toString() 方法在数组元素是数组的时候，会将里面的数组也调用 join()/toString() ,// 如果是对象的话，对象会被转为 [object Object] 字符串。 toLocaleString() 数组转字符串定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。 let a = [name: OBKoro1, 23, abcd, new Date()]console.log(a.join(,))console.log(a.toString())console.log(a.toLocaleString(en-us))console.log(a.toLocaleString(zh-cn))[object Object],23,abcd,Tue Feb 26 2019 11:47:03 GMT+0800 (中国标准时间)[object Object],23,abcd,Tue Feb 26 2019 11:47:03 GMT+0800 (中国标准时间)[object Object],23,abcd,2/26/2019, 11:47:03 AM[object Object],23,abcd,2019/2/26 上午 11:47:03 concat 合并数组定义： 方法用于合并两个或多个数组，返回一个新数组。 语法：var newArr =oldArray.concat(arrayX,arrayX,......,arrayX) 参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。 let a = [1, 2, 3];let b = [4, 5, 6];//连接两个数组let newVal = a.concat(b); // [1,2,3,4,5,6]// 连接三个数组let c = [7, 8, 9];let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9]// 添加元素let newVal3 = a.concat(添加元素, b, c, 再加一个);// [1,2,3,添加元素,4,5,6,7,8,9,再加一个]// 合并嵌套数组 会浅拷贝嵌套数组let d = [1, 2];let f = [3, [4]];let newVal4 = d.concat(f); // [1,2,3,[4]] ES6 扩展运算符 … 合并数组let a = [2, 3, 4, 5];let b = [4, ...a, 4, 4];console.log(a, b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回 0 而不是-1 语法：array.indexOf(searchElement,fromIndex) 参数： searchElement (必须):被查找的元素fromIndex (可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为 0。 严格相等的搜索:数组的 indexOf 搜索跟字符串的 indexOf 不一样,数组的 indexOf 使用严格相等搜索元素，即数组元素要完全匹配才能搜索成功。 注意：indexOf() 不能识别 NaN let a = [啦啦, 2, 4, 24, NaN];console.log(a.indexOf(啦)); // -1console.log(a.indexOf(NaN)); // -1console.log(a.indexOf(啦啦)); // 0 lastIndexOf() 查找指定元素在数组中的最后一个位置定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找） 语法：arr.lastIndexOf(searchElement,fromIndex) 参数: searchElement(必须): 被查找的元素fromIndex(可选): 逆向查找开始位置，默认值数组的 长度-1，即查找整个数组。 关于 fromIndex 有三个规则: 正值。如果该值大于或等于数组的长度，则整个数组会被查找。 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找) 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 let a = [OB, 4, Koro1, 1, 2, Koro1, 3, 4, 5, Koro1]; // 数组长度为 10// let b=a.lastIndexOf(Koro1,4) // 从下标 4 开始往前找 返回下标 2// let b=a.lastIndexOf(Koro1,100) // 大于或数组的长度 查找整个数组 返回 9// let b=a.lastIndexOf(Koro1,-11) // -1 数组不会被查找let b = a.lastIndexOf(Koro1, -9); // 从第二个元素 4 往前查找，没有找到 返回-1 ES7 includes() 查找数组是否包含某个元素 返回布尔定义： 返回一个布尔值，表示某个数组是否包含给定的值 语法：array.includes(searchElement,fromIndex=0) 参数： searchElement (必须):被查找的元素fromIndex (可选):默认值为 0 ，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回 false 。负值绝对值超过长数组度，重置从 0 开始搜索。 includes 方法是为了弥补 indexOf 方法的缺陷而出现的: indexOf 方法不能识别 NaN indexOf 方法检查是否包含某个值不够语义化，需要判断是否不等于 -1 ，表达不够直观 let a = [OB, Koro1, 1, NaN];// let b=a.includes(NaN) // true 识别NaN// let b=a.includes(Koro1,100) // false 超过数组长度 不搜索// let b=a.includes(Koro1,-3) // true 从倒数第三个元素开始搜索// let b=a.includes(Koro1,-100) // true 负值绝对值超过数组长度，搜索整个数组 参考：js 数组详细操作方法及解析合集","tags":["JS"]},{"title":"compose函数组合","path":"/2019/10/10/compose/","content":"在函数式编程当中有一个很重要的概念就是函数组合，实际上就是把处理数据的函数像管道一样连接起来，然后让数据穿过管道得到最终的结果 在多个框架源码中都有用到，比如 redux、koa 中多次遇到这个方法 效果：将一系列函数，通过 compose 函数组合起来，像管道一样连接起来，比如函数结合[f, g, h ]，通过 compose 最终达到这样的效果： f(g(h())) compose 函数要求：可执行同步方法，也可执行异步方法，两者都可以兼容 function compose(list) // 取出第一个函数，当做reduce函数的初始值 const init = list.shift(); return function (...arg) // 执行compose函数，返回一个函数 return list.reduce( (pre, cur) = // 返回list.reduce的结果，为一个promise实例，外部就可以通过then获取 return pre.then((result) = // pre始终为一个promise实例，result为结果的累加值 // 在前一个函数的then中，执行当前的函数，并返回一个promise实例，实现累加传递的效果 return cur.call(null, result); ); , // Promise.resolve可以将非promise实例转为promise实例（一种兼容处理） Promise.resolve(init.apply(null, arg)) ); ; // 同步方法案例let sync1 = (data) = console.log(sync1); return data;;let sync2 = (data) = console.log(sync2); return data + 1;;let sync3 = (data) = console.log(sync3); return data + 2;;let syncFn = compose([sync1, sync2, sync3]);syncFn(0).then((res) = console.log(res););// 依次打印 sync1 → sync2 → sync3 → 3// 异步方法案例let async1 = (data) = return new Promise((resolve) = setTimeout(() = console.log(async1); resolve(data); , 1000); );;let async2 = (data) = return new Promise((resolve) = setTimeout(() = console.log(async2); resolve(data + 1); , 1000); );;let async3 = (data) = return new Promise((resolve) = setTimeout(() = console.log(async3); resolve(data + 2); , 1000); );;let composeFn = compose([async1, async2, async3]);composeFn(0).then((res) = console.log(res););// 依次打印 async1 → async1 → async1 → 3","tags":["JS"]},{"title":"JS实现倒计时","path":"/2019/10/01/countdown/","content":"天，小时，分钟，秒钟倒计时 !DOCTYPE htmlhtml lang=en head meta charset=UTF-8 / meta name=viewport content=width=device-width, initial-scale=1.0 / titleDocument/title /head body div h1倒计时/h1 span class=day/span span class=hour/span span class=minute/span span class=second/span /div script const deadline = new Date(2019-10-1 00:00:00); const dayElement = document.querySelector(.day); const hourElement = document.querySelector(.hour); const minuteElement = document.querySelector(.minute); const secondElement = document.querySelector(.second); const countDown = () = const timeRemaining = deadline - new Date(); let day, hour, minute, second; if (timeRemaining 0) return 0; day = Math.floor(timeRemaining / 1000 / 60 / 60 / 24); hour = Math.floor((timeRemaining / 1000 / 60 / 60) % 24); minute = Math.floor((timeRemaining / 1000 / 60) % 60); second = Math.floor((timeRemaining / 1000) % 60); dayElement.innerHTML = day + 天; hourElement.innerHTML = hour + 时; minuteElement.innerHTML = minute + 分; secondElement.innerHTML = second + 秒; setTimeout(countDown, 1000); ; countDown(); /script /body/html","tags":["JS"]},{"title":"JSDoc","path":"/2018/03/04/JSDoc/","content":"这个是JSDoc 官方文档，我这边简单做一些介绍。 介绍JSDoc 3 是一个用于 JavaScript 的 API 文档生成器，类似于 Javadoc 或 phpDocumentor。可以将文档注释直接添加到源代码中。JSDoc 工具将扫描您的源代码并为您生成一个 HTML 文档网站。 向代码中添加文档注释JSDoc 的目的是记录 JavaScript 应用程序或库的 API。假设您想要记录诸如模块、名称空间、类、方法、方法参数等内容。 JSDoc 注释通常应该放在记录代码之前。为了被 JSDoc 解析器识别，每个注释必须以 ** 序列开头。以 、**开头或超过 3 颗星的注释将被忽略。这个特性用于控制解析注释块的功能。 可以使用特殊的 JSDoc 标签 来提供更多信息。例如，如果函数是类的构造函数，则可以通过添加 @constructor 标记来表示。 /** * Represents a book. * @constructor * @param string title - The title of the book. * @param string author - The author of the book. */function Book(title, author) 生成网站一旦你的代码是已注释的，你可以是用 JSDoc 3 的工具从源文件中生成一个 HTML 网站。 默认情况下，JSDoc 使用内置的“默认”模板将文档转换为 HTML。您可以根据自己的需要编辑此模板，或者创建一个全新的模板（如果您喜欢的话）。 在命令行上运行文档生成器： jsdoc book.js 此命令将在当前工作目录中创建名为 out/ 的目录。在该目录中，您将找到生成的 HTML 页面。","tags":["JS"]},{"title":"技术专栏","path":"/categories/index.html","content":"专栏说明这里按技术方向分类整理我的实战总结、源码解析与踩坑笔记，聚焦前端工程化、性能优化、多端开发等核心领域，持续沉淀可复用的技术方案。 技术分类导航1. 前端框架与生态 React 实战：Hooks 封装技巧、Redux 状态管理最佳实践、React 性能优化 Vue 3 进阶：Composition API 设计模式、Pinia 状态管理、Vue 组件封装 跨端开发：React NativeTarouniApp 多端适配、小程序性能优化 2. 工程化与架构 工程化落地：Webpack 配置优化、LoaderPlugin 开发、ESLintCommitlint 规范定制 微前端：Module Federation 实践、子应用通信、独立部署方案 低代码开发：拖拽引擎设计、物料体系搭建、属性配置逻辑 3. 性能优化 加载优化：首屏加载、分包加载、资源缓存策略 渲染优化：ReactVue 无效渲染优化、大数据量列表虚拟滚动 工程化优化：依赖优化、构建速度提升、打包体积压缩 4. 实战踩坑 企业级应用开发：权限管理（RBAC）、高并发场景处理 多端兼容：小程序样式兼容、跨浏览器适配问题 第三方库封装：IM 接口、图表可视化、表单组件二次开发 如何阅读 点击分类名称可查看对应技术方向的所有文章； 文章均附实战代码片段与效果演示，可直接复用； 持续更新中，欢迎通过评论区交流技术问题。"},{"title":"关于我","path":"/about/index.html","content":"个人简介4年+前端开发经验，专注企业级应用与多端开发，擅长 ReactVue 生态技术栈，具备从架构设计、工程化落地到性能优化的全流程开发能力。曾主导微前端架构落地、低代码平台搭建等核心项目，注重代码质量与用户体验，致力于用技术解决实际业务问题。 核心技术栈 前端框架：JavaScript（ES6+）、TypeScript、React 18、Vue 3、React Native、Taro、uni-app 状态管理：Redux、Redux Toolkit、Mitt、VuexPinia 工程化工具：Webpack 5、Babel、pnpm、ESLint、Commitlint、Husky、Storybook 多端开发：小程序、Electron、H5、PC 端、跨端应用（uni-appTaro） 其他技能：低代码平台开发、ECharts 数据可视化、NodeJS 后端基础、微前端（Module Federation）、Formily、Element Plus、Ant Design 教育经历 2017.9 - 2021.6 ：天津职业技术师范大学 | 计算机科学与技术（本科） 工作经历 2022.04 - 2025.06 ：北京万桥达观信息技术有限公司（Everbridge）| 前端开发 2021.06 - 2022.03 ：北京悦活教育科技有限公司 | 前端开发 联系方式 求职意向：前端开发工程师（可沟通远程驻场） 邮箱：1494601749@qq.com 博客：https://wmshero.github.io"},{"title":"项目作品集","path":"/projects/index.html","content":"核心项目 1：Everbridge 应急管理和风险情报系统技术栈：React + TypeScript + Style-Components + Redux + Webpack 5 + SWC + AntD + Sentry项目描述：主导开发的企业级核心系统，覆盖实时通信、位置感知、团队协作、事件任务管理、自动化流程、表单处理、文档管理、分析报告及自定义权限控制等功能，支撑日均 10 万+用户的高并发场景。 核心成果： 技术重构：引入 TypeScript 与 ESLint 规范，生产环境错误率降低 30%；用 pnpm 替换 npm 解决幽灵依赖，依赖安装效率提升 40%； 性能优化：Webpack 分包 + terser 压缩 + source-map 分析，首屏加载速度提升 20%；通过 React 性能 API 减少无效渲染，交互响应效率提升 30%； 质量保障：基于 Selenium 实现核心流程自动化测试，回归测试效率提升 50%；接入 Sentry 异常监控，问题修复时效缩短 40%； 通用能力封装：统一接口请求与错误处理逻辑，二次封装 AntD 组件并通过 Storybook 管理，团队开发效率提升 25%； 架构升级：基于 Webpack5 Module Federation 落地微前端，实现子应用独立部署，跨团队协作成本降低，迭代周期缩短 20%。 核心项目 2：希悦 Chalk 教育管理平台技术栈：React + React-Native + TypeScript + Style-Components + Redux + Formily + 腾讯 IM项目描述：覆盖 WebAPP 多端的教育管理平台，核心功能包括用户权限管理、课程学生场地管理、即时通讯、文件传输等，服务教师与学生日常教学协作场景。 核心成果： 工程化搭建：独立搭建项目脚手架，集成 ESLint、Husky、lint-staged 等工具，保障团队代码一致性； 功能封装：封装腾讯 IM 接口与请求工具，实现稳定的单聊、群聊及文件传输功能； 性能突破：基于 Formily 封装高性能表单组件，大数据量表单初始渲染时间从 17 秒优化至 3 秒内； 体验优化：通过按需加载、代码分割及接口数据缓存策略，优化 LCPFCP 指标，页面加载速度提升 40%。 核心项目 3：低代码可视化平台技术栈：Vue3 + Element-plus + Mitt + Sass + 拖拽引擎项目描述：从 0 到 1 开发的低代码平台，支持物料拖拽、属性配置、撤销重做、导入导出等功能，帮助非技术人员快速构建自定义表单，提升业务配置效率。 核心成果： 架构设计：基于 Mitt 实现拖拽事件监听与状态管理，精准控制物料移动与参照线展示； 组件能力：封装物料注册函数，支持组件属性栏动态配置与双向数据绑定，适配多样化表单需求； 交互优化：实现操作命令队列机制，支持鼠标右击与键盘快捷键操作，完善撤销重做功能体验。 核心项目 4：深脉分数专业版小程序技术栈：React + Taro + TypeScript + Style-Components + Redux Toolkit项目描述：面向医疗场景的小程序应用，提供医学影像分析、诊疗方案推荐、疾病解读等核心功能，兼顾数据可视化与多机型适配需求。 核心成果： 全流程开发：独立完成架构设计、页面开发到上线部署全流程，保障医疗数据展示的准确性与安全性； 埋点方案：开发 Babel 插件，通过 AST 语法分析自动为元素添加 data-id 埋点，实现用户行为全链路追踪； 性能适配：采用分包加载策略解决小程序体积限制，结合虚拟长列表优化大数据渲染性能，适配多机型样式兼容。 其他个人作品 众精普汇医学报告系统：React + AntD + jspdf（医学报告生成与导出） 刷景区小程序：Taro + React + Redux（景区票务查询、预约功能） 居然装饰官网（H5+PC）：React + Redux + AntD（品牌展示、业务咨询） 十安七律 CRM 小程序：Vue 全家桶 + uniApp + uCharts（客户管理、数据可视化）"}]